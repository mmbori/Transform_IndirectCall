int rc;
  do {
    const plugin *p = r->handler_module;
    if (NULL != p
        || ((rc = http_response_prepare(r)) == HANDLER_GO_ON
            && NULL != (p = r->handler_module)))
        rc = p->handle_subrequest(r, p->data);

    switch (rc) {
      case HANDLER_WAIT_FOR_EVENT:
        if (!r->resp_body_finished
            && (!r->resp_body_started
                || 0 == (r->conf.stream_response_body
                         & (FDEVENT_STREAM_RESPONSE
                           |FDEVENT_STREAM_RESPONSE_BUFMIN))))
            return HANDLER_WAIT_FOR_EVENT; /* come back here */
        /* response headers received from backend; start response */
        __attribute_fallthrough__
      case HANDLER_GO_ON:
      case HANDLER_FINISHED:
        if (r->http_status == 0) r->http_status = 200;
        if ((__builtin_expect( (r->http_status < 400), 1)
             && __builtin_expect( (0 == r->error_handler_saved_status), 1))
            || __builtin_expect( (!http_response_has_error_handler(r)), 1))
            /* we have something to send; go on */
            /*(CON_STATE_RESPONSE_START; transient state)*/
            return http_response_write_prepare(r);
        __attribute_fallthrough__
      case HANDLER_COMEBACK:
        http_response_comeback(r);
        rc = HANDLER_COMEBACK;
        continue;
      /*case HANDLER_ERROR:*/
      default:
        return HANDLER_ERROR; /* something went wrong */
    }
  } while (rc == HANDLER_COMEBACK);
 #ifndef __COVERITY__
  return HANDLER_ERROR; /* should not happen */ /*(not reached)*/
 #endif