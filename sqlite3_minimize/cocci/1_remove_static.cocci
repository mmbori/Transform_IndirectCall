// Auto-generated Coccinelle script to remove `static` keyword
// from specific functions listed in callsites.json and SQLite structure definitions
//
// This script uses identifier constraints to ensure precise matching
// and avoid false positives with similarly named types or variables.
//
// Enhanced features:
// - Position tracking for removed static keywords
// - Automatic extraction of function signatures to definitions/ folder
// - Support for various function declaration/definition formats
// - Improved pointer handling for return types and parameters
//
// Includes functions from:
// - callsites.json callee lists
// - sqlite3_mutex_methods structure (mutex functions)
// - sqlite3_mem_methods structure (memory functions)  
// - sqlite3_pcache_methods2 structure (page cache functions)
// - UNIXVFS structure (VFS functions)
//
// Usage: spatch --sp-file remove_static.cocci --dir <source_directory> --in-place


// Rules for function: absFunc
@remove_static_def_brace_same_line_absFunc@
identifier F = { absFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_absFunc@
identifier F = { absFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_absFunc@
identifier F = { absFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_absFunc@
identifier F = { absFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_absFunc@
identifier F = { absFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_absFunc@
F << remove_static_def_brace_same_line_absFunc.F;
T << remove_static_def_brace_same_line_absFunc.T;
P << remove_static_def_brace_same_line_absFunc.P;
p << remove_static_def_brace_same_line_absFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_absFunc@
F << remove_static_def_brace_next_line_absFunc.F;
T << remove_static_def_brace_next_line_absFunc.T;
P << remove_static_def_brace_next_line_absFunc.P;
p << remove_static_def_brace_next_line_absFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_absFunc@
F << remove_static_def_no_type_absFunc.F;
P << remove_static_def_no_type_absFunc.P;
p << remove_static_def_no_type_absFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_absFunc@
F << remove_static_decl_with_type_absFunc.F;
T << remove_static_decl_with_type_absFunc.T;
P << remove_static_decl_with_type_absFunc.P;
p << remove_static_decl_with_type_absFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_absFunc@
F << remove_static_inline_absFunc.F;
T << remove_static_inline_absFunc.T;
P << remove_static_inline_absFunc.P;
p << remove_static_inline_absFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: agginfoFree
@remove_static_def_brace_same_line_agginfoFree@
identifier F = { agginfoFree };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_agginfoFree@
identifier F = { agginfoFree };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_agginfoFree@
identifier F = { agginfoFree };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_agginfoFree@
identifier F = { agginfoFree };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_agginfoFree@
identifier F = { agginfoFree };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_agginfoFree@
F << remove_static_def_brace_same_line_agginfoFree.F;
T << remove_static_def_brace_same_line_agginfoFree.T;
P << remove_static_def_brace_same_line_agginfoFree.P;
p << remove_static_def_brace_same_line_agginfoFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_agginfoFree@
F << remove_static_def_brace_next_line_agginfoFree.F;
T << remove_static_def_brace_next_line_agginfoFree.T;
P << remove_static_def_brace_next_line_agginfoFree.P;
p << remove_static_def_brace_next_line_agginfoFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_agginfoFree@
F << remove_static_def_no_type_agginfoFree.F;
P << remove_static_def_no_type_agginfoFree.P;
p << remove_static_def_no_type_agginfoFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_agginfoFree@
F << remove_static_decl_with_type_agginfoFree.F;
T << remove_static_decl_with_type_agginfoFree.T;
P << remove_static_decl_with_type_agginfoFree.P;
p << remove_static_decl_with_type_agginfoFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_agginfoFree@
F << remove_static_inline_agginfoFree.F;
T << remove_static_inline_agginfoFree.T;
P << remove_static_inline_agginfoFree.P;
p << remove_static_inline_agginfoFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: agginfoPersistExprCb
@remove_static_def_brace_same_line_agginfoPersistExprCb@
identifier F = { agginfoPersistExprCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_agginfoPersistExprCb@
identifier F = { agginfoPersistExprCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_agginfoPersistExprCb@
identifier F = { agginfoPersistExprCb };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_agginfoPersistExprCb@
identifier F = { agginfoPersistExprCb };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_agginfoPersistExprCb@
identifier F = { agginfoPersistExprCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_agginfoPersistExprCb@
F << remove_static_def_brace_same_line_agginfoPersistExprCb.F;
T << remove_static_def_brace_same_line_agginfoPersistExprCb.T;
P << remove_static_def_brace_same_line_agginfoPersistExprCb.P;
p << remove_static_def_brace_same_line_agginfoPersistExprCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_agginfoPersistExprCb@
F << remove_static_def_brace_next_line_agginfoPersistExprCb.F;
T << remove_static_def_brace_next_line_agginfoPersistExprCb.T;
P << remove_static_def_brace_next_line_agginfoPersistExprCb.P;
p << remove_static_def_brace_next_line_agginfoPersistExprCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_agginfoPersistExprCb@
F << remove_static_def_no_type_agginfoPersistExprCb.F;
P << remove_static_def_no_type_agginfoPersistExprCb.P;
p << remove_static_def_no_type_agginfoPersistExprCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_agginfoPersistExprCb@
F << remove_static_decl_with_type_agginfoPersistExprCb.F;
T << remove_static_decl_with_type_agginfoPersistExprCb.T;
P << remove_static_decl_with_type_agginfoPersistExprCb.P;
p << remove_static_decl_with_type_agginfoPersistExprCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_agginfoPersistExprCb@
F << remove_static_inline_agginfoPersistExprCb.F;
T << remove_static_inline_agginfoPersistExprCb.T;
P << remove_static_inline_agginfoPersistExprCb.P;
p << remove_static_inline_agginfoPersistExprCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: analysisLoader
@remove_static_def_brace_same_line_analysisLoader@
identifier F = { analysisLoader };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_analysisLoader@
identifier F = { analysisLoader };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_analysisLoader@
identifier F = { analysisLoader };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_analysisLoader@
identifier F = { analysisLoader };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_analysisLoader@
identifier F = { analysisLoader };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_analysisLoader@
F << remove_static_def_brace_same_line_analysisLoader.F;
T << remove_static_def_brace_same_line_analysisLoader.T;
P << remove_static_def_brace_same_line_analysisLoader.P;
p << remove_static_def_brace_same_line_analysisLoader.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_analysisLoader@
F << remove_static_def_brace_next_line_analysisLoader.F;
T << remove_static_def_brace_next_line_analysisLoader.T;
P << remove_static_def_brace_next_line_analysisLoader.P;
p << remove_static_def_brace_next_line_analysisLoader.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_analysisLoader@
F << remove_static_def_no_type_analysisLoader.F;
P << remove_static_def_no_type_analysisLoader.P;
p << remove_static_def_no_type_analysisLoader.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_analysisLoader@
F << remove_static_decl_with_type_analysisLoader.F;
T << remove_static_decl_with_type_analysisLoader.T;
P << remove_static_decl_with_type_analysisLoader.P;
p << remove_static_decl_with_type_analysisLoader.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_analysisLoader@
F << remove_static_inline_analysisLoader.F;
T << remove_static_inline_analysisLoader.T;
P << remove_static_inline_analysisLoader.P;
p << remove_static_inline_analysisLoader.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: analyzeAggregate
@remove_static_def_brace_same_line_analyzeAggregate@
identifier F = { analyzeAggregate };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_analyzeAggregate@
identifier F = { analyzeAggregate };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_analyzeAggregate@
identifier F = { analyzeAggregate };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_analyzeAggregate@
identifier F = { analyzeAggregate };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_analyzeAggregate@
identifier F = { analyzeAggregate };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_analyzeAggregate@
F << remove_static_def_brace_same_line_analyzeAggregate.F;
T << remove_static_def_brace_same_line_analyzeAggregate.T;
P << remove_static_def_brace_same_line_analyzeAggregate.P;
p << remove_static_def_brace_same_line_analyzeAggregate.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_analyzeAggregate@
F << remove_static_def_brace_next_line_analyzeAggregate.F;
T << remove_static_def_brace_next_line_analyzeAggregate.T;
P << remove_static_def_brace_next_line_analyzeAggregate.P;
p << remove_static_def_brace_next_line_analyzeAggregate.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_analyzeAggregate@
F << remove_static_def_no_type_analyzeAggregate.F;
P << remove_static_def_no_type_analyzeAggregate.P;
p << remove_static_def_no_type_analyzeAggregate.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_analyzeAggregate@
F << remove_static_decl_with_type_analyzeAggregate.F;
T << remove_static_decl_with_type_analyzeAggregate.T;
P << remove_static_decl_with_type_analyzeAggregate.P;
p << remove_static_decl_with_type_analyzeAggregate.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_analyzeAggregate@
F << remove_static_inline_analyzeAggregate.F;
T << remove_static_inline_analyzeAggregate.T;
P << remove_static_inline_analyzeAggregate.P;
p << remove_static_inline_analyzeAggregate.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: attachFunc
@remove_static_def_brace_same_line_attachFunc@
identifier F = { attachFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_attachFunc@
identifier F = { attachFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_attachFunc@
identifier F = { attachFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_attachFunc@
identifier F = { attachFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_attachFunc@
identifier F = { attachFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_attachFunc@
F << remove_static_def_brace_same_line_attachFunc.F;
T << remove_static_def_brace_same_line_attachFunc.T;
P << remove_static_def_brace_same_line_attachFunc.P;
p << remove_static_def_brace_same_line_attachFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_attachFunc@
F << remove_static_def_brace_next_line_attachFunc.F;
T << remove_static_def_brace_next_line_attachFunc.T;
P << remove_static_def_brace_next_line_attachFunc.P;
p << remove_static_def_brace_next_line_attachFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_attachFunc@
F << remove_static_def_no_type_attachFunc.F;
P << remove_static_def_no_type_attachFunc.P;
p << remove_static_def_no_type_attachFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_attachFunc@
F << remove_static_decl_with_type_attachFunc.F;
T << remove_static_decl_with_type_attachFunc.T;
P << remove_static_decl_with_type_attachFunc.P;
p << remove_static_decl_with_type_attachFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_attachFunc@
F << remove_static_inline_attachFunc.F;
T << remove_static_inline_attachFunc.T;
P << remove_static_inline_attachFunc.P;
p << remove_static_inline_attachFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: avgFinalize
@remove_static_def_brace_same_line_avgFinalize@
identifier F = { avgFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_avgFinalize@
identifier F = { avgFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_avgFinalize@
identifier F = { avgFinalize };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_avgFinalize@
identifier F = { avgFinalize };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_avgFinalize@
identifier F = { avgFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_avgFinalize@
F << remove_static_def_brace_same_line_avgFinalize.F;
T << remove_static_def_brace_same_line_avgFinalize.T;
P << remove_static_def_brace_same_line_avgFinalize.P;
p << remove_static_def_brace_same_line_avgFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_avgFinalize@
F << remove_static_def_brace_next_line_avgFinalize.F;
T << remove_static_def_brace_next_line_avgFinalize.T;
P << remove_static_def_brace_next_line_avgFinalize.P;
p << remove_static_def_brace_next_line_avgFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_avgFinalize@
F << remove_static_def_no_type_avgFinalize.F;
P << remove_static_def_no_type_avgFinalize.P;
p << remove_static_def_no_type_avgFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_avgFinalize@
F << remove_static_decl_with_type_avgFinalize.F;
T << remove_static_decl_with_type_avgFinalize.T;
P << remove_static_decl_with_type_avgFinalize.P;
p << remove_static_decl_with_type_avgFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_avgFinalize@
F << remove_static_inline_avgFinalize.F;
T << remove_static_inline_avgFinalize.T;
P << remove_static_inline_avgFinalize.P;
p << remove_static_inline_avgFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: binCollFunc
@remove_static_def_brace_same_line_binCollFunc@
identifier F = { binCollFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_binCollFunc@
identifier F = { binCollFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_binCollFunc@
identifier F = { binCollFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_binCollFunc@
identifier F = { binCollFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_binCollFunc@
identifier F = { binCollFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_binCollFunc@
F << remove_static_def_brace_same_line_binCollFunc.F;
T << remove_static_def_brace_same_line_binCollFunc.T;
P << remove_static_def_brace_same_line_binCollFunc.P;
p << remove_static_def_brace_same_line_binCollFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_binCollFunc@
F << remove_static_def_brace_next_line_binCollFunc.F;
T << remove_static_def_brace_next_line_binCollFunc.T;
P << remove_static_def_brace_next_line_binCollFunc.P;
p << remove_static_def_brace_next_line_binCollFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_binCollFunc@
F << remove_static_def_no_type_binCollFunc.F;
P << remove_static_def_no_type_binCollFunc.P;
p << remove_static_def_no_type_binCollFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_binCollFunc@
F << remove_static_decl_with_type_binCollFunc.F;
T << remove_static_decl_with_type_binCollFunc.T;
P << remove_static_decl_with_type_binCollFunc.P;
p << remove_static_decl_with_type_binCollFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_binCollFunc@
F << remove_static_inline_binCollFunc.F;
T << remove_static_inline_binCollFunc.T;
P << remove_static_inline_binCollFunc.P;
p << remove_static_inline_binCollFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: btreeParseCellPtr
@remove_static_def_brace_same_line_btreeParseCellPtr@
identifier F = { btreeParseCellPtr };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_btreeParseCellPtr@
identifier F = { btreeParseCellPtr };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_btreeParseCellPtr@
identifier F = { btreeParseCellPtr };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_btreeParseCellPtr@
identifier F = { btreeParseCellPtr };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_btreeParseCellPtr@
identifier F = { btreeParseCellPtr };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_btreeParseCellPtr@
F << remove_static_def_brace_same_line_btreeParseCellPtr.F;
T << remove_static_def_brace_same_line_btreeParseCellPtr.T;
P << remove_static_def_brace_same_line_btreeParseCellPtr.P;
p << remove_static_def_brace_same_line_btreeParseCellPtr.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_btreeParseCellPtr@
F << remove_static_def_brace_next_line_btreeParseCellPtr.F;
T << remove_static_def_brace_next_line_btreeParseCellPtr.T;
P << remove_static_def_brace_next_line_btreeParseCellPtr.P;
p << remove_static_def_brace_next_line_btreeParseCellPtr.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_btreeParseCellPtr@
F << remove_static_def_no_type_btreeParseCellPtr.F;
P << remove_static_def_no_type_btreeParseCellPtr.P;
p << remove_static_def_no_type_btreeParseCellPtr.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_btreeParseCellPtr@
F << remove_static_decl_with_type_btreeParseCellPtr.F;
T << remove_static_decl_with_type_btreeParseCellPtr.T;
P << remove_static_decl_with_type_btreeParseCellPtr.P;
p << remove_static_decl_with_type_btreeParseCellPtr.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_btreeParseCellPtr@
F << remove_static_inline_btreeParseCellPtr.F;
T << remove_static_inline_btreeParseCellPtr.T;
P << remove_static_inline_btreeParseCellPtr.P;
p << remove_static_inline_btreeParseCellPtr.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: btreeParseCellPtrIndex
@remove_static_def_brace_same_line_btreeParseCellPtrIndex@
identifier F = { btreeParseCellPtrIndex };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_btreeParseCellPtrIndex@
identifier F = { btreeParseCellPtrIndex };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_btreeParseCellPtrIndex@
identifier F = { btreeParseCellPtrIndex };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_btreeParseCellPtrIndex@
identifier F = { btreeParseCellPtrIndex };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_btreeParseCellPtrIndex@
identifier F = { btreeParseCellPtrIndex };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_btreeParseCellPtrIndex@
F << remove_static_def_brace_same_line_btreeParseCellPtrIndex.F;
T << remove_static_def_brace_same_line_btreeParseCellPtrIndex.T;
P << remove_static_def_brace_same_line_btreeParseCellPtrIndex.P;
p << remove_static_def_brace_same_line_btreeParseCellPtrIndex.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_btreeParseCellPtrIndex@
F << remove_static_def_brace_next_line_btreeParseCellPtrIndex.F;
T << remove_static_def_brace_next_line_btreeParseCellPtrIndex.T;
P << remove_static_def_brace_next_line_btreeParseCellPtrIndex.P;
p << remove_static_def_brace_next_line_btreeParseCellPtrIndex.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_btreeParseCellPtrIndex@
F << remove_static_def_no_type_btreeParseCellPtrIndex.F;
P << remove_static_def_no_type_btreeParseCellPtrIndex.P;
p << remove_static_def_no_type_btreeParseCellPtrIndex.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_btreeParseCellPtrIndex@
F << remove_static_decl_with_type_btreeParseCellPtrIndex.F;
T << remove_static_decl_with_type_btreeParseCellPtrIndex.T;
P << remove_static_decl_with_type_btreeParseCellPtrIndex.P;
p << remove_static_decl_with_type_btreeParseCellPtrIndex.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_btreeParseCellPtrIndex@
F << remove_static_inline_btreeParseCellPtrIndex.F;
T << remove_static_inline_btreeParseCellPtrIndex.T;
P << remove_static_inline_btreeParseCellPtrIndex.P;
p << remove_static_inline_btreeParseCellPtrIndex.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: ceilingFunc
@remove_static_def_brace_same_line_ceilingFunc@
identifier F = { ceilingFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_ceilingFunc@
identifier F = { ceilingFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_ceilingFunc@
identifier F = { ceilingFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_ceilingFunc@
identifier F = { ceilingFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_ceilingFunc@
identifier F = { ceilingFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_ceilingFunc@
F << remove_static_def_brace_same_line_ceilingFunc.F;
T << remove_static_def_brace_same_line_ceilingFunc.T;
P << remove_static_def_brace_same_line_ceilingFunc.P;
p << remove_static_def_brace_same_line_ceilingFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_ceilingFunc@
F << remove_static_def_brace_next_line_ceilingFunc.F;
T << remove_static_def_brace_next_line_ceilingFunc.T;
P << remove_static_def_brace_next_line_ceilingFunc.P;
p << remove_static_def_brace_next_line_ceilingFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_ceilingFunc@
F << remove_static_def_no_type_ceilingFunc.F;
P << remove_static_def_no_type_ceilingFunc.P;
p << remove_static_def_no_type_ceilingFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_ceilingFunc@
F << remove_static_decl_with_type_ceilingFunc.F;
T << remove_static_decl_with_type_ceilingFunc.T;
P << remove_static_decl_with_type_ceilingFunc.P;
p << remove_static_decl_with_type_ceilingFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_ceilingFunc@
F << remove_static_inline_ceilingFunc.F;
T << remove_static_inline_ceilingFunc.T;
P << remove_static_inline_ceilingFunc.P;
p << remove_static_inline_ceilingFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: cellSizePtrTableLeaf
@remove_static_def_brace_same_line_cellSizePtrTableLeaf@
identifier F = { cellSizePtrTableLeaf };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_cellSizePtrTableLeaf@
identifier F = { cellSizePtrTableLeaf };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_cellSizePtrTableLeaf@
identifier F = { cellSizePtrTableLeaf };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_cellSizePtrTableLeaf@
identifier F = { cellSizePtrTableLeaf };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_cellSizePtrTableLeaf@
identifier F = { cellSizePtrTableLeaf };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_cellSizePtrTableLeaf@
F << remove_static_def_brace_same_line_cellSizePtrTableLeaf.F;
T << remove_static_def_brace_same_line_cellSizePtrTableLeaf.T;
P << remove_static_def_brace_same_line_cellSizePtrTableLeaf.P;
p << remove_static_def_brace_same_line_cellSizePtrTableLeaf.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_cellSizePtrTableLeaf@
F << remove_static_def_brace_next_line_cellSizePtrTableLeaf.F;
T << remove_static_def_brace_next_line_cellSizePtrTableLeaf.T;
P << remove_static_def_brace_next_line_cellSizePtrTableLeaf.P;
p << remove_static_def_brace_next_line_cellSizePtrTableLeaf.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_cellSizePtrTableLeaf@
F << remove_static_def_no_type_cellSizePtrTableLeaf.F;
P << remove_static_def_no_type_cellSizePtrTableLeaf.P;
p << remove_static_def_no_type_cellSizePtrTableLeaf.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_cellSizePtrTableLeaf@
F << remove_static_decl_with_type_cellSizePtrTableLeaf.F;
T << remove_static_decl_with_type_cellSizePtrTableLeaf.T;
P << remove_static_decl_with_type_cellSizePtrTableLeaf.P;
p << remove_static_decl_with_type_cellSizePtrTableLeaf.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_cellSizePtrTableLeaf@
F << remove_static_inline_cellSizePtrTableLeaf.F;
T << remove_static_inline_cellSizePtrTableLeaf.T;
P << remove_static_inline_cellSizePtrTableLeaf.P;
p << remove_static_inline_cellSizePtrTableLeaf.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: changes
@remove_static_def_brace_same_line_changes@
identifier F = { changes };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_changes@
identifier F = { changes };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_changes@
identifier F = { changes };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_changes@
identifier F = { changes };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_changes@
identifier F = { changes };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_changes@
F << remove_static_def_brace_same_line_changes.F;
T << remove_static_def_brace_same_line_changes.T;
P << remove_static_def_brace_same_line_changes.P;
p << remove_static_def_brace_same_line_changes.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_changes@
F << remove_static_def_brace_next_line_changes.F;
T << remove_static_def_brace_next_line_changes.T;
P << remove_static_def_brace_next_line_changes.P;
p << remove_static_def_brace_next_line_changes.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_changes@
F << remove_static_def_no_type_changes.F;
P << remove_static_def_no_type_changes.P;
p << remove_static_def_no_type_changes.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_changes@
F << remove_static_decl_with_type_changes.F;
T << remove_static_decl_with_type_changes.T;
P << remove_static_decl_with_type_changes.P;
p << remove_static_decl_with_type_changes.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_changes@
F << remove_static_inline_changes.F;
T << remove_static_inline_changes.T;
P << remove_static_inline_changes.P;
p << remove_static_inline_changes.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: charFunc
@remove_static_def_brace_same_line_charFunc@
identifier F = { charFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_charFunc@
identifier F = { charFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_charFunc@
identifier F = { charFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_charFunc@
identifier F = { charFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_charFunc@
identifier F = { charFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_charFunc@
F << remove_static_def_brace_same_line_charFunc.F;
T << remove_static_def_brace_same_line_charFunc.T;
P << remove_static_def_brace_same_line_charFunc.P;
p << remove_static_def_brace_same_line_charFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_charFunc@
F << remove_static_def_brace_next_line_charFunc.F;
T << remove_static_def_brace_next_line_charFunc.T;
P << remove_static_def_brace_next_line_charFunc.P;
p << remove_static_def_brace_next_line_charFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_charFunc@
F << remove_static_def_no_type_charFunc.F;
P << remove_static_def_no_type_charFunc.P;
p << remove_static_def_no_type_charFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_charFunc@
F << remove_static_decl_with_type_charFunc.F;
T << remove_static_decl_with_type_charFunc.T;
P << remove_static_decl_with_type_charFunc.P;
p << remove_static_decl_with_type_charFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_charFunc@
F << remove_static_inline_charFunc.F;
T << remove_static_inline_charFunc.T;
P << remove_static_inline_charFunc.P;
p << remove_static_inline_charFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: checkConstraintExprNode
@remove_static_def_brace_same_line_checkConstraintExprNode@
identifier F = { checkConstraintExprNode };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_checkConstraintExprNode@
identifier F = { checkConstraintExprNode };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_checkConstraintExprNode@
identifier F = { checkConstraintExprNode };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_checkConstraintExprNode@
identifier F = { checkConstraintExprNode };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_checkConstraintExprNode@
identifier F = { checkConstraintExprNode };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_checkConstraintExprNode@
F << remove_static_def_brace_same_line_checkConstraintExprNode.F;
T << remove_static_def_brace_same_line_checkConstraintExprNode.T;
P << remove_static_def_brace_same_line_checkConstraintExprNode.P;
p << remove_static_def_brace_same_line_checkConstraintExprNode.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_checkConstraintExprNode@
F << remove_static_def_brace_next_line_checkConstraintExprNode.F;
T << remove_static_def_brace_next_line_checkConstraintExprNode.T;
P << remove_static_def_brace_next_line_checkConstraintExprNode.P;
p << remove_static_def_brace_next_line_checkConstraintExprNode.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_checkConstraintExprNode@
F << remove_static_def_no_type_checkConstraintExprNode.F;
P << remove_static_def_no_type_checkConstraintExprNode.P;
p << remove_static_def_no_type_checkConstraintExprNode.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_checkConstraintExprNode@
F << remove_static_decl_with_type_checkConstraintExprNode.F;
T << remove_static_decl_with_type_checkConstraintExprNode.T;
P << remove_static_decl_with_type_checkConstraintExprNode.P;
p << remove_static_decl_with_type_checkConstraintExprNode.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_checkConstraintExprNode@
F << remove_static_inline_checkConstraintExprNode.F;
T << remove_static_inline_checkConstraintExprNode.T;
P << remove_static_inline_checkConstraintExprNode.P;
p << remove_static_inline_checkConstraintExprNode.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: countFinalize
@remove_static_def_brace_same_line_countFinalize@
identifier F = { countFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_countFinalize@
identifier F = { countFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_countFinalize@
identifier F = { countFinalize };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_countFinalize@
identifier F = { countFinalize };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_countFinalize@
identifier F = { countFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_countFinalize@
F << remove_static_def_brace_same_line_countFinalize.F;
T << remove_static_def_brace_same_line_countFinalize.T;
P << remove_static_def_brace_same_line_countFinalize.P;
p << remove_static_def_brace_same_line_countFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_countFinalize@
F << remove_static_def_brace_next_line_countFinalize.F;
T << remove_static_def_brace_next_line_countFinalize.T;
P << remove_static_def_brace_next_line_countFinalize.P;
p << remove_static_def_brace_next_line_countFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_countFinalize@
F << remove_static_def_no_type_countFinalize.F;
P << remove_static_def_no_type_countFinalize.P;
p << remove_static_def_no_type_countFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_countFinalize@
F << remove_static_decl_with_type_countFinalize.F;
T << remove_static_decl_with_type_countFinalize.T;
P << remove_static_decl_with_type_countFinalize.P;
p << remove_static_decl_with_type_countFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_countFinalize@
F << remove_static_inline_countFinalize.F;
T << remove_static_inline_countFinalize.T;
P << remove_static_inline_countFinalize.P;
p << remove_static_inline_countFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: countStep
@remove_static_def_brace_same_line_countStep@
identifier F = { countStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_countStep@
identifier F = { countStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_countStep@
identifier F = { countStep };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_countStep@
identifier F = { countStep };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_countStep@
identifier F = { countStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_countStep@
F << remove_static_def_brace_same_line_countStep.F;
T << remove_static_def_brace_same_line_countStep.T;
P << remove_static_def_brace_same_line_countStep.P;
p << remove_static_def_brace_same_line_countStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_countStep@
F << remove_static_def_brace_next_line_countStep.F;
T << remove_static_def_brace_next_line_countStep.T;
P << remove_static_def_brace_next_line_countStep.P;
p << remove_static_def_brace_next_line_countStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_countStep@
F << remove_static_def_no_type_countStep.F;
P << remove_static_def_no_type_countStep.P;
p << remove_static_def_no_type_countStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_countStep@
F << remove_static_decl_with_type_countStep.F;
T << remove_static_decl_with_type_countStep.T;
P << remove_static_decl_with_type_countStep.P;
p << remove_static_decl_with_type_countStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_countStep@
F << remove_static_inline_countStep.F;
T << remove_static_inline_countStep.T;
P << remove_static_inline_countStep.P;
p << remove_static_inline_countStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: ctimestampFunc
@remove_static_def_brace_same_line_ctimestampFunc@
identifier F = { ctimestampFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_ctimestampFunc@
identifier F = { ctimestampFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_ctimestampFunc@
identifier F = { ctimestampFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_ctimestampFunc@
identifier F = { ctimestampFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_ctimestampFunc@
identifier F = { ctimestampFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_ctimestampFunc@
F << remove_static_def_brace_same_line_ctimestampFunc.F;
T << remove_static_def_brace_same_line_ctimestampFunc.T;
P << remove_static_def_brace_same_line_ctimestampFunc.P;
p << remove_static_def_brace_same_line_ctimestampFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_ctimestampFunc@
F << remove_static_def_brace_next_line_ctimestampFunc.F;
T << remove_static_def_brace_next_line_ctimestampFunc.T;
P << remove_static_def_brace_next_line_ctimestampFunc.P;
p << remove_static_def_brace_next_line_ctimestampFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_ctimestampFunc@
F << remove_static_def_no_type_ctimestampFunc.F;
P << remove_static_def_no_type_ctimestampFunc.P;
p << remove_static_def_no_type_ctimestampFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_ctimestampFunc@
F << remove_static_decl_with_type_ctimestampFunc.F;
T << remove_static_decl_with_type_ctimestampFunc.T;
P << remove_static_decl_with_type_ctimestampFunc.P;
p << remove_static_decl_with_type_ctimestampFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_ctimestampFunc@
F << remove_static_inline_ctimestampFunc.F;
T << remove_static_inline_ctimestampFunc.T;
P << remove_static_inline_ctimestampFunc.P;
p << remove_static_inline_ctimestampFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: dateFunc
@remove_static_def_brace_same_line_dateFunc@
identifier F = { dateFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_dateFunc@
identifier F = { dateFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_dateFunc@
identifier F = { dateFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_dateFunc@
identifier F = { dateFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_dateFunc@
identifier F = { dateFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_dateFunc@
F << remove_static_def_brace_same_line_dateFunc.F;
T << remove_static_def_brace_same_line_dateFunc.T;
P << remove_static_def_brace_same_line_dateFunc.P;
p << remove_static_def_brace_same_line_dateFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_dateFunc@
F << remove_static_def_brace_next_line_dateFunc.F;
T << remove_static_def_brace_next_line_dateFunc.T;
P << remove_static_def_brace_next_line_dateFunc.P;
p << remove_static_def_brace_next_line_dateFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_dateFunc@
F << remove_static_def_no_type_dateFunc.F;
P << remove_static_def_no_type_dateFunc.P;
p << remove_static_def_no_type_dateFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_dateFunc@
F << remove_static_decl_with_type_dateFunc.F;
T << remove_static_decl_with_type_dateFunc.T;
P << remove_static_decl_with_type_dateFunc.P;
p << remove_static_decl_with_type_dateFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_dateFunc@
F << remove_static_inline_dateFunc.F;
T << remove_static_inline_dateFunc.T;
P << remove_static_inline_dateFunc.P;
p << remove_static_inline_dateFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: datetimeFunc
@remove_static_def_brace_same_line_datetimeFunc@
identifier F = { datetimeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_datetimeFunc@
identifier F = { datetimeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_datetimeFunc@
identifier F = { datetimeFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_datetimeFunc@
identifier F = { datetimeFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_datetimeFunc@
identifier F = { datetimeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_datetimeFunc@
F << remove_static_def_brace_same_line_datetimeFunc.F;
T << remove_static_def_brace_same_line_datetimeFunc.T;
P << remove_static_def_brace_same_line_datetimeFunc.P;
p << remove_static_def_brace_same_line_datetimeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_datetimeFunc@
F << remove_static_def_brace_next_line_datetimeFunc.F;
T << remove_static_def_brace_next_line_datetimeFunc.T;
P << remove_static_def_brace_next_line_datetimeFunc.P;
p << remove_static_def_brace_next_line_datetimeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_datetimeFunc@
F << remove_static_def_no_type_datetimeFunc.F;
P << remove_static_def_no_type_datetimeFunc.P;
p << remove_static_def_no_type_datetimeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_datetimeFunc@
F << remove_static_decl_with_type_datetimeFunc.F;
T << remove_static_decl_with_type_datetimeFunc.T;
P << remove_static_decl_with_type_datetimeFunc.P;
p << remove_static_decl_with_type_datetimeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_datetimeFunc@
F << remove_static_inline_datetimeFunc.F;
T << remove_static_inline_datetimeFunc.T;
P << remove_static_inline_datetimeFunc.P;
p << remove_static_inline_datetimeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: dense_rankStepFunc
@remove_static_def_brace_same_line_dense_rankStepFunc@
identifier F = { dense_rankStepFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_dense_rankStepFunc@
identifier F = { dense_rankStepFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_dense_rankStepFunc@
identifier F = { dense_rankStepFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_dense_rankStepFunc@
identifier F = { dense_rankStepFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_dense_rankStepFunc@
identifier F = { dense_rankStepFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_dense_rankStepFunc@
F << remove_static_def_brace_same_line_dense_rankStepFunc.F;
T << remove_static_def_brace_same_line_dense_rankStepFunc.T;
P << remove_static_def_brace_same_line_dense_rankStepFunc.P;
p << remove_static_def_brace_same_line_dense_rankStepFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_dense_rankStepFunc@
F << remove_static_def_brace_next_line_dense_rankStepFunc.F;
T << remove_static_def_brace_next_line_dense_rankStepFunc.T;
P << remove_static_def_brace_next_line_dense_rankStepFunc.P;
p << remove_static_def_brace_next_line_dense_rankStepFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_dense_rankStepFunc@
F << remove_static_def_no_type_dense_rankStepFunc.F;
P << remove_static_def_no_type_dense_rankStepFunc.P;
p << remove_static_def_no_type_dense_rankStepFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_dense_rankStepFunc@
F << remove_static_decl_with_type_dense_rankStepFunc.F;
T << remove_static_decl_with_type_dense_rankStepFunc.T;
P << remove_static_decl_with_type_dense_rankStepFunc.P;
p << remove_static_decl_with_type_dense_rankStepFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_dense_rankStepFunc@
F << remove_static_inline_dense_rankStepFunc.F;
T << remove_static_inline_dense_rankStepFunc.T;
P << remove_static_inline_dense_rankStepFunc.P;
p << remove_static_inline_dense_rankStepFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: dense_rankValueFunc
@remove_static_def_brace_same_line_dense_rankValueFunc@
identifier F = { dense_rankValueFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_dense_rankValueFunc@
identifier F = { dense_rankValueFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_dense_rankValueFunc@
identifier F = { dense_rankValueFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_dense_rankValueFunc@
identifier F = { dense_rankValueFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_dense_rankValueFunc@
identifier F = { dense_rankValueFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_dense_rankValueFunc@
F << remove_static_def_brace_same_line_dense_rankValueFunc.F;
T << remove_static_def_brace_same_line_dense_rankValueFunc.T;
P << remove_static_def_brace_same_line_dense_rankValueFunc.P;
p << remove_static_def_brace_same_line_dense_rankValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_dense_rankValueFunc@
F << remove_static_def_brace_next_line_dense_rankValueFunc.F;
T << remove_static_def_brace_next_line_dense_rankValueFunc.T;
P << remove_static_def_brace_next_line_dense_rankValueFunc.P;
p << remove_static_def_brace_next_line_dense_rankValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_dense_rankValueFunc@
F << remove_static_def_no_type_dense_rankValueFunc.F;
P << remove_static_def_no_type_dense_rankValueFunc.P;
p << remove_static_def_no_type_dense_rankValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_dense_rankValueFunc@
F << remove_static_decl_with_type_dense_rankValueFunc.F;
T << remove_static_decl_with_type_dense_rankValueFunc.T;
P << remove_static_decl_with_type_dense_rankValueFunc.P;
p << remove_static_decl_with_type_dense_rankValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_dense_rankValueFunc@
F << remove_static_inline_dense_rankValueFunc.F;
T << remove_static_inline_dense_rankValueFunc.T;
P << remove_static_inline_dense_rankValueFunc.P;
p << remove_static_inline_dense_rankValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: disallowAggregatesInOrderByCb
@remove_static_def_brace_same_line_disallowAggregatesInOrderByCb@
identifier F = { disallowAggregatesInOrderByCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_disallowAggregatesInOrderByCb@
identifier F = { disallowAggregatesInOrderByCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_disallowAggregatesInOrderByCb@
identifier F = { disallowAggregatesInOrderByCb };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_disallowAggregatesInOrderByCb@
identifier F = { disallowAggregatesInOrderByCb };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_disallowAggregatesInOrderByCb@
identifier F = { disallowAggregatesInOrderByCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_disallowAggregatesInOrderByCb@
F << remove_static_def_brace_same_line_disallowAggregatesInOrderByCb.F;
T << remove_static_def_brace_same_line_disallowAggregatesInOrderByCb.T;
P << remove_static_def_brace_same_line_disallowAggregatesInOrderByCb.P;
p << remove_static_def_brace_same_line_disallowAggregatesInOrderByCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_disallowAggregatesInOrderByCb@
F << remove_static_def_brace_next_line_disallowAggregatesInOrderByCb.F;
T << remove_static_def_brace_next_line_disallowAggregatesInOrderByCb.T;
P << remove_static_def_brace_next_line_disallowAggregatesInOrderByCb.P;
p << remove_static_def_brace_next_line_disallowAggregatesInOrderByCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_disallowAggregatesInOrderByCb@
F << remove_static_def_no_type_disallowAggregatesInOrderByCb.F;
P << remove_static_def_no_type_disallowAggregatesInOrderByCb.P;
p << remove_static_def_no_type_disallowAggregatesInOrderByCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_disallowAggregatesInOrderByCb@
F << remove_static_decl_with_type_disallowAggregatesInOrderByCb.F;
T << remove_static_decl_with_type_disallowAggregatesInOrderByCb.T;
P << remove_static_decl_with_type_disallowAggregatesInOrderByCb.P;
p << remove_static_decl_with_type_disallowAggregatesInOrderByCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_disallowAggregatesInOrderByCb@
F << remove_static_inline_disallowAggregatesInOrderByCb.F;
T << remove_static_inline_disallowAggregatesInOrderByCb.T;
P << remove_static_inline_disallowAggregatesInOrderByCb.P;
p << remove_static_inline_disallowAggregatesInOrderByCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: exprIdxCover
@remove_static_def_brace_same_line_exprIdxCover@
identifier F = { exprIdxCover };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_exprIdxCover@
identifier F = { exprIdxCover };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_exprIdxCover@
identifier F = { exprIdxCover };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_exprIdxCover@
identifier F = { exprIdxCover };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_exprIdxCover@
identifier F = { exprIdxCover };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_exprIdxCover@
F << remove_static_def_brace_same_line_exprIdxCover.F;
T << remove_static_def_brace_same_line_exprIdxCover.T;
P << remove_static_def_brace_same_line_exprIdxCover.P;
p << remove_static_def_brace_same_line_exprIdxCover.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_exprIdxCover@
F << remove_static_def_brace_next_line_exprIdxCover.F;
T << remove_static_def_brace_next_line_exprIdxCover.T;
P << remove_static_def_brace_next_line_exprIdxCover.P;
p << remove_static_def_brace_next_line_exprIdxCover.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_exprIdxCover@
F << remove_static_def_no_type_exprIdxCover.F;
P << remove_static_def_no_type_exprIdxCover.P;
p << remove_static_def_no_type_exprIdxCover.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_exprIdxCover@
F << remove_static_decl_with_type_exprIdxCover.F;
T << remove_static_decl_with_type_exprIdxCover.T;
P << remove_static_decl_with_type_exprIdxCover.P;
p << remove_static_decl_with_type_exprIdxCover.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_exprIdxCover@
F << remove_static_inline_exprIdxCover.F;
T << remove_static_inline_exprIdxCover.T;
P << remove_static_inline_exprIdxCover.P;
p << remove_static_inline_exprIdxCover.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: exprNodeIsConstant
@remove_static_def_brace_same_line_exprNodeIsConstant@
identifier F = { exprNodeIsConstant };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_exprNodeIsConstant@
identifier F = { exprNodeIsConstant };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_exprNodeIsConstant@
identifier F = { exprNodeIsConstant };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_exprNodeIsConstant@
identifier F = { exprNodeIsConstant };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_exprNodeIsConstant@
identifier F = { exprNodeIsConstant };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_exprNodeIsConstant@
F << remove_static_def_brace_same_line_exprNodeIsConstant.F;
T << remove_static_def_brace_same_line_exprNodeIsConstant.T;
P << remove_static_def_brace_same_line_exprNodeIsConstant.P;
p << remove_static_def_brace_same_line_exprNodeIsConstant.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_exprNodeIsConstant@
F << remove_static_def_brace_next_line_exprNodeIsConstant.F;
T << remove_static_def_brace_next_line_exprNodeIsConstant.T;
P << remove_static_def_brace_next_line_exprNodeIsConstant.P;
p << remove_static_def_brace_next_line_exprNodeIsConstant.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_exprNodeIsConstant@
F << remove_static_def_no_type_exprNodeIsConstant.F;
P << remove_static_def_no_type_exprNodeIsConstant.P;
p << remove_static_def_no_type_exprNodeIsConstant.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_exprNodeIsConstant@
F << remove_static_decl_with_type_exprNodeIsConstant.F;
T << remove_static_decl_with_type_exprNodeIsConstant.T;
P << remove_static_decl_with_type_exprNodeIsConstant.P;
p << remove_static_decl_with_type_exprNodeIsConstant.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_exprNodeIsConstant@
F << remove_static_inline_exprNodeIsConstant.F;
T << remove_static_inline_exprNodeIsConstant.T;
P << remove_static_inline_exprNodeIsConstant.P;
p << remove_static_inline_exprNodeIsConstant.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: exprNodeIsDeterministic
@remove_static_def_brace_same_line_exprNodeIsDeterministic@
identifier F = { exprNodeIsDeterministic };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_exprNodeIsDeterministic@
identifier F = { exprNodeIsDeterministic };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_exprNodeIsDeterministic@
identifier F = { exprNodeIsDeterministic };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_exprNodeIsDeterministic@
identifier F = { exprNodeIsDeterministic };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_exprNodeIsDeterministic@
identifier F = { exprNodeIsDeterministic };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_exprNodeIsDeterministic@
F << remove_static_def_brace_same_line_exprNodeIsDeterministic.F;
T << remove_static_def_brace_same_line_exprNodeIsDeterministic.T;
P << remove_static_def_brace_same_line_exprNodeIsDeterministic.P;
p << remove_static_def_brace_same_line_exprNodeIsDeterministic.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_exprNodeIsDeterministic@
F << remove_static_def_brace_next_line_exprNodeIsDeterministic.F;
T << remove_static_def_brace_next_line_exprNodeIsDeterministic.T;
P << remove_static_def_brace_next_line_exprNodeIsDeterministic.P;
p << remove_static_def_brace_next_line_exprNodeIsDeterministic.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_exprNodeIsDeterministic@
F << remove_static_def_no_type_exprNodeIsDeterministic.F;
P << remove_static_def_no_type_exprNodeIsDeterministic.P;
p << remove_static_def_no_type_exprNodeIsDeterministic.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_exprNodeIsDeterministic@
F << remove_static_decl_with_type_exprNodeIsDeterministic.F;
T << remove_static_decl_with_type_exprNodeIsDeterministic.T;
P << remove_static_decl_with_type_exprNodeIsDeterministic.P;
p << remove_static_decl_with_type_exprNodeIsDeterministic.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_exprNodeIsDeterministic@
F << remove_static_inline_exprNodeIsDeterministic.F;
T << remove_static_inline_exprNodeIsDeterministic.T;
P << remove_static_inline_exprNodeIsDeterministic.P;
p << remove_static_inline_exprNodeIsDeterministic.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: exprRefToSrcList
@remove_static_def_brace_same_line_exprRefToSrcList@
identifier F = { exprRefToSrcList };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_exprRefToSrcList@
identifier F = { exprRefToSrcList };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_exprRefToSrcList@
identifier F = { exprRefToSrcList };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_exprRefToSrcList@
identifier F = { exprRefToSrcList };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_exprRefToSrcList@
identifier F = { exprRefToSrcList };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_exprRefToSrcList@
F << remove_static_def_brace_same_line_exprRefToSrcList.F;
T << remove_static_def_brace_same_line_exprRefToSrcList.T;
P << remove_static_def_brace_same_line_exprRefToSrcList.P;
p << remove_static_def_brace_same_line_exprRefToSrcList.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_exprRefToSrcList@
F << remove_static_def_brace_next_line_exprRefToSrcList.F;
T << remove_static_def_brace_next_line_exprRefToSrcList.T;
P << remove_static_def_brace_next_line_exprRefToSrcList.P;
p << remove_static_def_brace_next_line_exprRefToSrcList.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_exprRefToSrcList@
F << remove_static_def_no_type_exprRefToSrcList.F;
P << remove_static_def_no_type_exprRefToSrcList.P;
p << remove_static_def_no_type_exprRefToSrcList.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_exprRefToSrcList@
F << remove_static_decl_with_type_exprRefToSrcList.F;
T << remove_static_decl_with_type_exprRefToSrcList.T;
P << remove_static_decl_with_type_exprRefToSrcList.P;
p << remove_static_decl_with_type_exprRefToSrcList.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_exprRefToSrcList@
F << remove_static_inline_exprRefToSrcList.F;
T << remove_static_inline_exprRefToSrcList.T;
P << remove_static_inline_exprRefToSrcList.P;
p << remove_static_inline_exprRefToSrcList.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: fixExprCb
@remove_static_def_brace_same_line_fixExprCb@
identifier F = { fixExprCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_fixExprCb@
identifier F = { fixExprCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_fixExprCb@
identifier F = { fixExprCb };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_fixExprCb@
identifier F = { fixExprCb };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_fixExprCb@
identifier F = { fixExprCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_fixExprCb@
F << remove_static_def_brace_same_line_fixExprCb.F;
T << remove_static_def_brace_same_line_fixExprCb.T;
P << remove_static_def_brace_same_line_fixExprCb.P;
p << remove_static_def_brace_same_line_fixExprCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_fixExprCb@
F << remove_static_def_brace_next_line_fixExprCb.F;
T << remove_static_def_brace_next_line_fixExprCb.T;
P << remove_static_def_brace_next_line_fixExprCb.P;
p << remove_static_def_brace_next_line_fixExprCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_fixExprCb@
F << remove_static_def_no_type_fixExprCb.F;
P << remove_static_def_no_type_fixExprCb.P;
p << remove_static_def_no_type_fixExprCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_fixExprCb@
F << remove_static_decl_with_type_fixExprCb.F;
T << remove_static_decl_with_type_fixExprCb.T;
P << remove_static_decl_with_type_fixExprCb.P;
p << remove_static_decl_with_type_fixExprCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_fixExprCb@
F << remove_static_inline_fixExprCb.F;
T << remove_static_inline_fixExprCb.T;
P << remove_static_inline_fixExprCb.P;
p << remove_static_inline_fixExprCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: fixSelectCb
@remove_static_def_brace_same_line_fixSelectCb@
identifier F = { fixSelectCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_fixSelectCb@
identifier F = { fixSelectCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_fixSelectCb@
identifier F = { fixSelectCb };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_fixSelectCb@
identifier F = { fixSelectCb };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_fixSelectCb@
identifier F = { fixSelectCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_fixSelectCb@
F << remove_static_def_brace_same_line_fixSelectCb.F;
T << remove_static_def_brace_same_line_fixSelectCb.T;
P << remove_static_def_brace_same_line_fixSelectCb.P;
p << remove_static_def_brace_same_line_fixSelectCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_fixSelectCb@
F << remove_static_def_brace_next_line_fixSelectCb.F;
T << remove_static_def_brace_next_line_fixSelectCb.T;
P << remove_static_def_brace_next_line_fixSelectCb.P;
p << remove_static_def_brace_next_line_fixSelectCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_fixSelectCb@
F << remove_static_def_no_type_fixSelectCb.F;
P << remove_static_def_no_type_fixSelectCb.P;
p << remove_static_def_no_type_fixSelectCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_fixSelectCb@
F << remove_static_decl_with_type_fixSelectCb.F;
T << remove_static_decl_with_type_fixSelectCb.T;
P << remove_static_decl_with_type_fixSelectCb.P;
p << remove_static_decl_with_type_fixSelectCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_fixSelectCb@
F << remove_static_inline_fixSelectCb.F;
T << remove_static_inline_fixSelectCb.T;
P << remove_static_inline_fixSelectCb.P;
p << remove_static_inline_fixSelectCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: fts3StrCompare
@remove_static_def_brace_same_line_fts3StrCompare@
identifier F = { fts3StrCompare };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_fts3StrCompare@
identifier F = { fts3StrCompare };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_fts3StrCompare@
identifier F = { fts3StrCompare };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_fts3StrCompare@
identifier F = { fts3StrCompare };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_fts3StrCompare@
identifier F = { fts3StrCompare };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_fts3StrCompare@
F << remove_static_def_brace_same_line_fts3StrCompare.F;
T << remove_static_def_brace_same_line_fts3StrCompare.T;
P << remove_static_def_brace_same_line_fts3StrCompare.P;
p << remove_static_def_brace_same_line_fts3StrCompare.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_fts3StrCompare@
F << remove_static_def_brace_next_line_fts3StrCompare.F;
T << remove_static_def_brace_next_line_fts3StrCompare.T;
P << remove_static_def_brace_next_line_fts3StrCompare.P;
p << remove_static_def_brace_next_line_fts3StrCompare.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_fts3StrCompare@
F << remove_static_def_no_type_fts3StrCompare.F;
P << remove_static_def_no_type_fts3StrCompare.P;
p << remove_static_def_no_type_fts3StrCompare.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_fts3StrCompare@
F << remove_static_decl_with_type_fts3StrCompare.F;
T << remove_static_decl_with_type_fts3StrCompare.T;
P << remove_static_decl_with_type_fts3StrCompare.P;
p << remove_static_decl_with_type_fts3StrCompare.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_fts3StrCompare@
F << remove_static_inline_fts3StrCompare.F;
T << remove_static_inline_fts3StrCompare.T;
P << remove_static_inline_fts3StrCompare.P;
p << remove_static_inline_fts3StrCompare.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: fts3StrHash
@remove_static_def_brace_same_line_fts3StrHash@
identifier F = { fts3StrHash };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_fts3StrHash@
identifier F = { fts3StrHash };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_fts3StrHash@
identifier F = { fts3StrHash };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_fts3StrHash@
identifier F = { fts3StrHash };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_fts3StrHash@
identifier F = { fts3StrHash };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_fts3StrHash@
F << remove_static_def_brace_same_line_fts3StrHash.F;
T << remove_static_def_brace_same_line_fts3StrHash.T;
P << remove_static_def_brace_same_line_fts3StrHash.P;
p << remove_static_def_brace_same_line_fts3StrHash.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_fts3StrHash@
F << remove_static_def_brace_next_line_fts3StrHash.F;
T << remove_static_def_brace_next_line_fts3StrHash.T;
P << remove_static_def_brace_next_line_fts3StrHash.P;
p << remove_static_def_brace_next_line_fts3StrHash.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_fts3StrHash@
F << remove_static_def_no_type_fts3StrHash.F;
P << remove_static_def_no_type_fts3StrHash.P;
p << remove_static_def_no_type_fts3StrHash.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_fts3StrHash@
F << remove_static_decl_with_type_fts3StrHash.F;
T << remove_static_decl_with_type_fts3StrHash.T;
P << remove_static_decl_with_type_fts3StrHash.P;
p << remove_static_decl_with_type_fts3StrHash.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_fts3StrHash@
F << remove_static_inline_fts3StrHash.F;
T << remove_static_inline_fts3StrHash.T;
P << remove_static_inline_fts3StrHash.P;
p << remove_static_inline_fts3StrHash.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: getPageError
@remove_static_def_brace_same_line_getPageError@
identifier F = { getPageError };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_getPageError@
identifier F = { getPageError };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_getPageError@
identifier F = { getPageError };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_getPageError@
identifier F = { getPageError };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_getPageError@
identifier F = { getPageError };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_getPageError@
F << remove_static_def_brace_same_line_getPageError.F;
T << remove_static_def_brace_same_line_getPageError.T;
P << remove_static_def_brace_same_line_getPageError.P;
p << remove_static_def_brace_same_line_getPageError.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_getPageError@
F << remove_static_def_brace_next_line_getPageError.F;
T << remove_static_def_brace_next_line_getPageError.T;
P << remove_static_def_brace_next_line_getPageError.P;
p << remove_static_def_brace_next_line_getPageError.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_getPageError@
F << remove_static_def_no_type_getPageError.F;
P << remove_static_def_no_type_getPageError.P;
p << remove_static_def_no_type_getPageError.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_getPageError@
F << remove_static_decl_with_type_getPageError.F;
T << remove_static_decl_with_type_getPageError.T;
P << remove_static_decl_with_type_getPageError.P;
p << remove_static_decl_with_type_getPageError.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_getPageError@
F << remove_static_inline_getPageError.F;
T << remove_static_inline_getPageError.T;
P << remove_static_inline_getPageError.P;
p << remove_static_inline_getPageError.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: getPageNormal
@remove_static_def_brace_same_line_getPageNormal@
identifier F = { getPageNormal };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_getPageNormal@
identifier F = { getPageNormal };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_getPageNormal@
identifier F = { getPageNormal };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_getPageNormal@
identifier F = { getPageNormal };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_getPageNormal@
identifier F = { getPageNormal };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_getPageNormal@
F << remove_static_def_brace_same_line_getPageNormal.F;
T << remove_static_def_brace_same_line_getPageNormal.T;
P << remove_static_def_brace_same_line_getPageNormal.P;
p << remove_static_def_brace_same_line_getPageNormal.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_getPageNormal@
F << remove_static_def_brace_next_line_getPageNormal.F;
T << remove_static_def_brace_next_line_getPageNormal.T;
P << remove_static_def_brace_next_line_getPageNormal.P;
p << remove_static_def_brace_next_line_getPageNormal.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_getPageNormal@
F << remove_static_def_no_type_getPageNormal.F;
P << remove_static_def_no_type_getPageNormal.P;
p << remove_static_def_no_type_getPageNormal.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_getPageNormal@
F << remove_static_decl_with_type_getPageNormal.F;
T << remove_static_decl_with_type_getPageNormal.T;
P << remove_static_decl_with_type_getPageNormal.P;
p << remove_static_decl_with_type_getPageNormal.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_getPageNormal@
F << remove_static_inline_getPageNormal.F;
T << remove_static_inline_getPageNormal.T;
P << remove_static_inline_getPageNormal.P;
p << remove_static_inline_getPageNormal.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: groupConcatFinalize
@remove_static_def_brace_same_line_groupConcatFinalize@
identifier F = { groupConcatFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_groupConcatFinalize@
identifier F = { groupConcatFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_groupConcatFinalize@
identifier F = { groupConcatFinalize };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_groupConcatFinalize@
identifier F = { groupConcatFinalize };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_groupConcatFinalize@
identifier F = { groupConcatFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_groupConcatFinalize@
F << remove_static_def_brace_same_line_groupConcatFinalize.F;
T << remove_static_def_brace_same_line_groupConcatFinalize.T;
P << remove_static_def_brace_same_line_groupConcatFinalize.P;
p << remove_static_def_brace_same_line_groupConcatFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_groupConcatFinalize@
F << remove_static_def_brace_next_line_groupConcatFinalize.F;
T << remove_static_def_brace_next_line_groupConcatFinalize.T;
P << remove_static_def_brace_next_line_groupConcatFinalize.P;
p << remove_static_def_brace_next_line_groupConcatFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_groupConcatFinalize@
F << remove_static_def_no_type_groupConcatFinalize.F;
P << remove_static_def_no_type_groupConcatFinalize.P;
p << remove_static_def_no_type_groupConcatFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_groupConcatFinalize@
F << remove_static_decl_with_type_groupConcatFinalize.F;
T << remove_static_decl_with_type_groupConcatFinalize.T;
P << remove_static_decl_with_type_groupConcatFinalize.P;
p << remove_static_decl_with_type_groupConcatFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_groupConcatFinalize@
F << remove_static_inline_groupConcatFinalize.F;
T << remove_static_inline_groupConcatFinalize.T;
P << remove_static_inline_groupConcatFinalize.P;
p << remove_static_inline_groupConcatFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: groupConcatStep
@remove_static_def_brace_same_line_groupConcatStep@
identifier F = { groupConcatStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_groupConcatStep@
identifier F = { groupConcatStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_groupConcatStep@
identifier F = { groupConcatStep };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_groupConcatStep@
identifier F = { groupConcatStep };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_groupConcatStep@
identifier F = { groupConcatStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_groupConcatStep@
F << remove_static_def_brace_same_line_groupConcatStep.F;
T << remove_static_def_brace_same_line_groupConcatStep.T;
P << remove_static_def_brace_same_line_groupConcatStep.P;
p << remove_static_def_brace_same_line_groupConcatStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_groupConcatStep@
F << remove_static_def_brace_next_line_groupConcatStep.F;
T << remove_static_def_brace_next_line_groupConcatStep.T;
P << remove_static_def_brace_next_line_groupConcatStep.P;
p << remove_static_def_brace_next_line_groupConcatStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_groupConcatStep@
F << remove_static_def_no_type_groupConcatStep.F;
P << remove_static_def_no_type_groupConcatStep.P;
p << remove_static_def_no_type_groupConcatStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_groupConcatStep@
F << remove_static_decl_with_type_groupConcatStep.F;
T << remove_static_decl_with_type_groupConcatStep.T;
P << remove_static_decl_with_type_groupConcatStep.P;
p << remove_static_decl_with_type_groupConcatStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_groupConcatStep@
F << remove_static_inline_groupConcatStep.F;
T << remove_static_inline_groupConcatStep.T;
P << remove_static_inline_groupConcatStep.P;
p << remove_static_inline_groupConcatStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: hashDestroy
@remove_static_def_brace_same_line_hashDestroy@
identifier F = { hashDestroy };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_hashDestroy@
identifier F = { hashDestroy };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_hashDestroy@
identifier F = { hashDestroy };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_hashDestroy@
identifier F = { hashDestroy };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_hashDestroy@
identifier F = { hashDestroy };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_hashDestroy@
F << remove_static_def_brace_same_line_hashDestroy.F;
T << remove_static_def_brace_same_line_hashDestroy.T;
P << remove_static_def_brace_same_line_hashDestroy.P;
p << remove_static_def_brace_same_line_hashDestroy.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_hashDestroy@
F << remove_static_def_brace_next_line_hashDestroy.F;
T << remove_static_def_brace_next_line_hashDestroy.T;
P << remove_static_def_brace_next_line_hashDestroy.P;
p << remove_static_def_brace_next_line_hashDestroy.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_hashDestroy@
F << remove_static_def_no_type_hashDestroy.F;
P << remove_static_def_no_type_hashDestroy.P;
p << remove_static_def_no_type_hashDestroy.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_hashDestroy@
F << remove_static_decl_with_type_hashDestroy.F;
T << remove_static_decl_with_type_hashDestroy.T;
P << remove_static_decl_with_type_hashDestroy.P;
p << remove_static_decl_with_type_hashDestroy.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_hashDestroy@
F << remove_static_inline_hashDestroy.F;
T << remove_static_inline_hashDestroy.T;
P << remove_static_inline_hashDestroy.P;
p << remove_static_inline_hashDestroy.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: hexFunc
@remove_static_def_brace_same_line_hexFunc@
identifier F = { hexFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_hexFunc@
identifier F = { hexFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_hexFunc@
identifier F = { hexFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_hexFunc@
identifier F = { hexFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_hexFunc@
identifier F = { hexFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_hexFunc@
F << remove_static_def_brace_same_line_hexFunc.F;
T << remove_static_def_brace_same_line_hexFunc.T;
P << remove_static_def_brace_same_line_hexFunc.P;
p << remove_static_def_brace_same_line_hexFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_hexFunc@
F << remove_static_def_brace_next_line_hexFunc.F;
T << remove_static_def_brace_next_line_hexFunc.T;
P << remove_static_def_brace_next_line_hexFunc.P;
p << remove_static_def_brace_next_line_hexFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_hexFunc@
F << remove_static_def_no_type_hexFunc.F;
P << remove_static_def_no_type_hexFunc.P;
p << remove_static_def_no_type_hexFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_hexFunc@
F << remove_static_decl_with_type_hexFunc.F;
T << remove_static_decl_with_type_hexFunc.T;
P << remove_static_decl_with_type_hexFunc.P;
p << remove_static_decl_with_type_hexFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_hexFunc@
F << remove_static_inline_hexFunc.F;
T << remove_static_inline_hexFunc.T;
P << remove_static_inline_hexFunc.P;
p << remove_static_inline_hexFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: impliesNotNullRow
@remove_static_def_brace_same_line_impliesNotNullRow@
identifier F = { impliesNotNullRow };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_impliesNotNullRow@
identifier F = { impliesNotNullRow };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_impliesNotNullRow@
identifier F = { impliesNotNullRow };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_impliesNotNullRow@
identifier F = { impliesNotNullRow };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_impliesNotNullRow@
identifier F = { impliesNotNullRow };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_impliesNotNullRow@
F << remove_static_def_brace_same_line_impliesNotNullRow.F;
T << remove_static_def_brace_same_line_impliesNotNullRow.T;
P << remove_static_def_brace_same_line_impliesNotNullRow.P;
p << remove_static_def_brace_same_line_impliesNotNullRow.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_impliesNotNullRow@
F << remove_static_def_brace_next_line_impliesNotNullRow.F;
T << remove_static_def_brace_next_line_impliesNotNullRow.T;
P << remove_static_def_brace_next_line_impliesNotNullRow.P;
p << remove_static_def_brace_next_line_impliesNotNullRow.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_impliesNotNullRow@
F << remove_static_def_no_type_impliesNotNullRow.F;
P << remove_static_def_no_type_impliesNotNullRow.P;
p << remove_static_def_no_type_impliesNotNullRow.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_impliesNotNullRow@
F << remove_static_decl_with_type_impliesNotNullRow.F;
T << remove_static_decl_with_type_impliesNotNullRow.T;
P << remove_static_decl_with_type_impliesNotNullRow.P;
p << remove_static_decl_with_type_impliesNotNullRow.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_impliesNotNullRow@
F << remove_static_inline_impliesNotNullRow.F;
T << remove_static_inline_impliesNotNullRow.T;
P << remove_static_inline_impliesNotNullRow.P;
p << remove_static_inline_impliesNotNullRow.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: instrFunc
@remove_static_def_brace_same_line_instrFunc@
identifier F = { instrFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_instrFunc@
identifier F = { instrFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_instrFunc@
identifier F = { instrFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_instrFunc@
identifier F = { instrFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_instrFunc@
identifier F = { instrFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_instrFunc@
F << remove_static_def_brace_same_line_instrFunc.F;
T << remove_static_def_brace_same_line_instrFunc.T;
P << remove_static_def_brace_same_line_instrFunc.P;
p << remove_static_def_brace_same_line_instrFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_instrFunc@
F << remove_static_def_brace_next_line_instrFunc.F;
T << remove_static_def_brace_next_line_instrFunc.T;
P << remove_static_def_brace_next_line_instrFunc.P;
p << remove_static_def_brace_next_line_instrFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_instrFunc@
F << remove_static_def_no_type_instrFunc.F;
P << remove_static_def_no_type_instrFunc.P;
p << remove_static_def_no_type_instrFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_instrFunc@
F << remove_static_decl_with_type_instrFunc.F;
T << remove_static_decl_with_type_instrFunc.T;
P << remove_static_decl_with_type_instrFunc.P;
p << remove_static_decl_with_type_instrFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_instrFunc@
F << remove_static_inline_instrFunc.F;
T << remove_static_inline_instrFunc.T;
P << remove_static_inline_instrFunc.P;
p << remove_static_inline_instrFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: jsonArrayFunc
@remove_static_def_brace_same_line_jsonArrayFunc@
identifier F = { jsonArrayFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_jsonArrayFunc@
identifier F = { jsonArrayFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_jsonArrayFunc@
identifier F = { jsonArrayFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_jsonArrayFunc@
identifier F = { jsonArrayFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_jsonArrayFunc@
identifier F = { jsonArrayFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_jsonArrayFunc@
F << remove_static_def_brace_same_line_jsonArrayFunc.F;
T << remove_static_def_brace_same_line_jsonArrayFunc.T;
P << remove_static_def_brace_same_line_jsonArrayFunc.P;
p << remove_static_def_brace_same_line_jsonArrayFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_jsonArrayFunc@
F << remove_static_def_brace_next_line_jsonArrayFunc.F;
T << remove_static_def_brace_next_line_jsonArrayFunc.T;
P << remove_static_def_brace_next_line_jsonArrayFunc.P;
p << remove_static_def_brace_next_line_jsonArrayFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_jsonArrayFunc@
F << remove_static_def_no_type_jsonArrayFunc.F;
P << remove_static_def_no_type_jsonArrayFunc.P;
p << remove_static_def_no_type_jsonArrayFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_jsonArrayFunc@
F << remove_static_decl_with_type_jsonArrayFunc.F;
T << remove_static_decl_with_type_jsonArrayFunc.T;
P << remove_static_decl_with_type_jsonArrayFunc.P;
p << remove_static_decl_with_type_jsonArrayFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_jsonArrayFunc@
F << remove_static_inline_jsonArrayFunc.F;
T << remove_static_inline_jsonArrayFunc.T;
P << remove_static_inline_jsonArrayFunc.P;
p << remove_static_inline_jsonArrayFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: jsonCacheDeleteGeneric
@remove_static_def_brace_same_line_jsonCacheDeleteGeneric@
identifier F = { jsonCacheDeleteGeneric };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_jsonCacheDeleteGeneric@
identifier F = { jsonCacheDeleteGeneric };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_jsonCacheDeleteGeneric@
identifier F = { jsonCacheDeleteGeneric };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_jsonCacheDeleteGeneric@
identifier F = { jsonCacheDeleteGeneric };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_jsonCacheDeleteGeneric@
identifier F = { jsonCacheDeleteGeneric };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_jsonCacheDeleteGeneric@
F << remove_static_def_brace_same_line_jsonCacheDeleteGeneric.F;
T << remove_static_def_brace_same_line_jsonCacheDeleteGeneric.T;
P << remove_static_def_brace_same_line_jsonCacheDeleteGeneric.P;
p << remove_static_def_brace_same_line_jsonCacheDeleteGeneric.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_jsonCacheDeleteGeneric@
F << remove_static_def_brace_next_line_jsonCacheDeleteGeneric.F;
T << remove_static_def_brace_next_line_jsonCacheDeleteGeneric.T;
P << remove_static_def_brace_next_line_jsonCacheDeleteGeneric.P;
p << remove_static_def_brace_next_line_jsonCacheDeleteGeneric.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_jsonCacheDeleteGeneric@
F << remove_static_def_no_type_jsonCacheDeleteGeneric.F;
P << remove_static_def_no_type_jsonCacheDeleteGeneric.P;
p << remove_static_def_no_type_jsonCacheDeleteGeneric.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_jsonCacheDeleteGeneric@
F << remove_static_decl_with_type_jsonCacheDeleteGeneric.F;
T << remove_static_decl_with_type_jsonCacheDeleteGeneric.T;
P << remove_static_decl_with_type_jsonCacheDeleteGeneric.P;
p << remove_static_decl_with_type_jsonCacheDeleteGeneric.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_jsonCacheDeleteGeneric@
F << remove_static_inline_jsonCacheDeleteGeneric.F;
T << remove_static_inline_jsonCacheDeleteGeneric.T;
P << remove_static_inline_jsonCacheDeleteGeneric.P;
p << remove_static_inline_jsonCacheDeleteGeneric.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: jsonObjectFunc
@remove_static_def_brace_same_line_jsonObjectFunc@
identifier F = { jsonObjectFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_jsonObjectFunc@
identifier F = { jsonObjectFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_jsonObjectFunc@
identifier F = { jsonObjectFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_jsonObjectFunc@
identifier F = { jsonObjectFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_jsonObjectFunc@
identifier F = { jsonObjectFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_jsonObjectFunc@
F << remove_static_def_brace_same_line_jsonObjectFunc.F;
T << remove_static_def_brace_same_line_jsonObjectFunc.T;
P << remove_static_def_brace_same_line_jsonObjectFunc.P;
p << remove_static_def_brace_same_line_jsonObjectFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_jsonObjectFunc@
F << remove_static_def_brace_next_line_jsonObjectFunc.F;
T << remove_static_def_brace_next_line_jsonObjectFunc.T;
P << remove_static_def_brace_next_line_jsonObjectFunc.P;
p << remove_static_def_brace_next_line_jsonObjectFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_jsonObjectFunc@
F << remove_static_def_no_type_jsonObjectFunc.F;
P << remove_static_def_no_type_jsonObjectFunc.P;
p << remove_static_def_no_type_jsonObjectFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_jsonObjectFunc@
F << remove_static_decl_with_type_jsonObjectFunc.F;
T << remove_static_decl_with_type_jsonObjectFunc.T;
P << remove_static_decl_with_type_jsonObjectFunc.P;
p << remove_static_decl_with_type_jsonObjectFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_jsonObjectFunc@
F << remove_static_inline_jsonObjectFunc.F;
T << remove_static_inline_jsonObjectFunc.T;
P << remove_static_inline_jsonObjectFunc.P;
p << remove_static_inline_jsonObjectFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: jsonTypeFunc
@remove_static_def_brace_same_line_jsonTypeFunc@
identifier F = { jsonTypeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_jsonTypeFunc@
identifier F = { jsonTypeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_jsonTypeFunc@
identifier F = { jsonTypeFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_jsonTypeFunc@
identifier F = { jsonTypeFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_jsonTypeFunc@
identifier F = { jsonTypeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_jsonTypeFunc@
F << remove_static_def_brace_same_line_jsonTypeFunc.F;
T << remove_static_def_brace_same_line_jsonTypeFunc.T;
P << remove_static_def_brace_same_line_jsonTypeFunc.P;
p << remove_static_def_brace_same_line_jsonTypeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_jsonTypeFunc@
F << remove_static_def_brace_next_line_jsonTypeFunc.F;
T << remove_static_def_brace_next_line_jsonTypeFunc.T;
P << remove_static_def_brace_next_line_jsonTypeFunc.P;
p << remove_static_def_brace_next_line_jsonTypeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_jsonTypeFunc@
F << remove_static_def_no_type_jsonTypeFunc.F;
P << remove_static_def_no_type_jsonTypeFunc.P;
p << remove_static_def_no_type_jsonTypeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_jsonTypeFunc@
F << remove_static_decl_with_type_jsonTypeFunc.F;
T << remove_static_decl_with_type_jsonTypeFunc.T;
P << remove_static_decl_with_type_jsonTypeFunc.P;
p << remove_static_decl_with_type_jsonTypeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_jsonTypeFunc@
F << remove_static_inline_jsonTypeFunc.F;
T << remove_static_inline_jsonTypeFunc.T;
P << remove_static_inline_jsonTypeFunc.P;
p << remove_static_inline_jsonTypeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: juliandayFunc
@remove_static_def_brace_same_line_juliandayFunc@
identifier F = { juliandayFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_juliandayFunc@
identifier F = { juliandayFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_juliandayFunc@
identifier F = { juliandayFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_juliandayFunc@
identifier F = { juliandayFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_juliandayFunc@
identifier F = { juliandayFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_juliandayFunc@
F << remove_static_def_brace_same_line_juliandayFunc.F;
T << remove_static_def_brace_same_line_juliandayFunc.T;
P << remove_static_def_brace_same_line_juliandayFunc.P;
p << remove_static_def_brace_same_line_juliandayFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_juliandayFunc@
F << remove_static_def_brace_next_line_juliandayFunc.F;
T << remove_static_def_brace_next_line_juliandayFunc.T;
P << remove_static_def_brace_next_line_juliandayFunc.P;
p << remove_static_def_brace_next_line_juliandayFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_juliandayFunc@
F << remove_static_def_no_type_juliandayFunc.F;
P << remove_static_def_no_type_juliandayFunc.P;
p << remove_static_def_no_type_juliandayFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_juliandayFunc@
F << remove_static_decl_with_type_juliandayFunc.F;
T << remove_static_decl_with_type_juliandayFunc.T;
P << remove_static_decl_with_type_juliandayFunc.P;
p << remove_static_decl_with_type_juliandayFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_juliandayFunc@
F << remove_static_inline_juliandayFunc.F;
T << remove_static_inline_juliandayFunc.T;
P << remove_static_inline_juliandayFunc.P;
p << remove_static_inline_juliandayFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: last_insert_rowid
@remove_static_def_brace_same_line_last_insert_rowid@
identifier F = { last_insert_rowid };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_last_insert_rowid@
identifier F = { last_insert_rowid };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_last_insert_rowid@
identifier F = { last_insert_rowid };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_last_insert_rowid@
identifier F = { last_insert_rowid };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_last_insert_rowid@
identifier F = { last_insert_rowid };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_last_insert_rowid@
F << remove_static_def_brace_same_line_last_insert_rowid.F;
T << remove_static_def_brace_same_line_last_insert_rowid.T;
P << remove_static_def_brace_same_line_last_insert_rowid.P;
p << remove_static_def_brace_same_line_last_insert_rowid.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_last_insert_rowid@
F << remove_static_def_brace_next_line_last_insert_rowid.F;
T << remove_static_def_brace_next_line_last_insert_rowid.T;
P << remove_static_def_brace_next_line_last_insert_rowid.P;
p << remove_static_def_brace_next_line_last_insert_rowid.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_last_insert_rowid@
F << remove_static_def_no_type_last_insert_rowid.F;
P << remove_static_def_no_type_last_insert_rowid.P;
p << remove_static_def_no_type_last_insert_rowid.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_last_insert_rowid@
F << remove_static_decl_with_type_last_insert_rowid.F;
T << remove_static_decl_with_type_last_insert_rowid.T;
P << remove_static_decl_with_type_last_insert_rowid.P;
p << remove_static_decl_with_type_last_insert_rowid.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_last_insert_rowid@
F << remove_static_inline_last_insert_rowid.F;
T << remove_static_inline_last_insert_rowid.T;
P << remove_static_inline_last_insert_rowid.P;
p << remove_static_inline_last_insert_rowid.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: lengthFunc
@remove_static_def_brace_same_line_lengthFunc@
identifier F = { lengthFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_lengthFunc@
identifier F = { lengthFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_lengthFunc@
identifier F = { lengthFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_lengthFunc@
identifier F = { lengthFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_lengthFunc@
identifier F = { lengthFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_lengthFunc@
F << remove_static_def_brace_same_line_lengthFunc.F;
T << remove_static_def_brace_same_line_lengthFunc.T;
P << remove_static_def_brace_same_line_lengthFunc.P;
p << remove_static_def_brace_same_line_lengthFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_lengthFunc@
F << remove_static_def_brace_next_line_lengthFunc.F;
T << remove_static_def_brace_next_line_lengthFunc.T;
P << remove_static_def_brace_next_line_lengthFunc.P;
p << remove_static_def_brace_next_line_lengthFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_lengthFunc@
F << remove_static_def_no_type_lengthFunc.F;
P << remove_static_def_no_type_lengthFunc.P;
p << remove_static_def_no_type_lengthFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_lengthFunc@
F << remove_static_decl_with_type_lengthFunc.F;
T << remove_static_decl_with_type_lengthFunc.T;
P << remove_static_decl_with_type_lengthFunc.P;
p << remove_static_decl_with_type_lengthFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_lengthFunc@
F << remove_static_inline_lengthFunc.F;
T << remove_static_inline_lengthFunc.T;
P << remove_static_inline_lengthFunc.P;
p << remove_static_inline_lengthFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: likeFunc
@remove_static_def_brace_same_line_likeFunc@
identifier F = { likeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_likeFunc@
identifier F = { likeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_likeFunc@
identifier F = { likeFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_likeFunc@
identifier F = { likeFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_likeFunc@
identifier F = { likeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_likeFunc@
F << remove_static_def_brace_same_line_likeFunc.F;
T << remove_static_def_brace_same_line_likeFunc.T;
P << remove_static_def_brace_same_line_likeFunc.P;
p << remove_static_def_brace_same_line_likeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_likeFunc@
F << remove_static_def_brace_next_line_likeFunc.F;
T << remove_static_def_brace_next_line_likeFunc.T;
P << remove_static_def_brace_next_line_likeFunc.P;
p << remove_static_def_brace_next_line_likeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_likeFunc@
F << remove_static_def_no_type_likeFunc.F;
P << remove_static_def_no_type_likeFunc.P;
p << remove_static_def_no_type_likeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_likeFunc@
F << remove_static_decl_with_type_likeFunc.F;
T << remove_static_decl_with_type_likeFunc.T;
P << remove_static_decl_with_type_likeFunc.P;
p << remove_static_decl_with_type_likeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_likeFunc@
F << remove_static_inline_likeFunc.F;
T << remove_static_inline_likeFunc.T;
P << remove_static_inline_likeFunc.P;
p << remove_static_inline_likeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: logFunc
@remove_static_def_brace_same_line_logFunc@
identifier F = { logFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_logFunc@
identifier F = { logFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_logFunc@
identifier F = { logFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_logFunc@
identifier F = { logFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_logFunc@
identifier F = { logFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_logFunc@
F << remove_static_def_brace_same_line_logFunc.F;
T << remove_static_def_brace_same_line_logFunc.T;
P << remove_static_def_brace_same_line_logFunc.P;
p << remove_static_def_brace_same_line_logFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_logFunc@
F << remove_static_def_brace_next_line_logFunc.F;
T << remove_static_def_brace_next_line_logFunc.T;
P << remove_static_def_brace_next_line_logFunc.P;
p << remove_static_def_brace_next_line_logFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_logFunc@
F << remove_static_def_no_type_logFunc.F;
P << remove_static_def_no_type_logFunc.P;
p << remove_static_def_no_type_logFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_logFunc@
F << remove_static_decl_with_type_logFunc.F;
T << remove_static_decl_with_type_logFunc.T;
P << remove_static_decl_with_type_logFunc.P;
p << remove_static_decl_with_type_logFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_logFunc@
F << remove_static_inline_logFunc.F;
T << remove_static_inline_logFunc.T;
P << remove_static_inline_logFunc.P;
p << remove_static_inline_logFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: lowerFunc
@remove_static_def_brace_same_line_lowerFunc@
identifier F = { lowerFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_lowerFunc@
identifier F = { lowerFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_lowerFunc@
identifier F = { lowerFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_lowerFunc@
identifier F = { lowerFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_lowerFunc@
identifier F = { lowerFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_lowerFunc@
F << remove_static_def_brace_same_line_lowerFunc.F;
T << remove_static_def_brace_same_line_lowerFunc.T;
P << remove_static_def_brace_same_line_lowerFunc.P;
p << remove_static_def_brace_same_line_lowerFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_lowerFunc@
F << remove_static_def_brace_next_line_lowerFunc.F;
T << remove_static_def_brace_next_line_lowerFunc.T;
P << remove_static_def_brace_next_line_lowerFunc.P;
p << remove_static_def_brace_next_line_lowerFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_lowerFunc@
F << remove_static_def_no_type_lowerFunc.F;
P << remove_static_def_no_type_lowerFunc.P;
p << remove_static_def_no_type_lowerFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_lowerFunc@
F << remove_static_decl_with_type_lowerFunc.F;
T << remove_static_decl_with_type_lowerFunc.T;
P << remove_static_decl_with_type_lowerFunc.P;
p << remove_static_decl_with_type_lowerFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_lowerFunc@
F << remove_static_inline_lowerFunc.F;
T << remove_static_inline_lowerFunc.T;
P << remove_static_inline_lowerFunc.P;
p << remove_static_inline_lowerFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: math1Func
@remove_static_def_brace_same_line_math1Func@
identifier F = { math1Func };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_math1Func@
identifier F = { math1Func };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_math1Func@
identifier F = { math1Func };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_math1Func@
identifier F = { math1Func };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_math1Func@
identifier F = { math1Func };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_math1Func@
F << remove_static_def_brace_same_line_math1Func.F;
T << remove_static_def_brace_same_line_math1Func.T;
P << remove_static_def_brace_same_line_math1Func.P;
p << remove_static_def_brace_same_line_math1Func.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_math1Func@
F << remove_static_def_brace_next_line_math1Func.F;
T << remove_static_def_brace_next_line_math1Func.T;
P << remove_static_def_brace_next_line_math1Func.P;
p << remove_static_def_brace_next_line_math1Func.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_math1Func@
F << remove_static_def_no_type_math1Func.F;
P << remove_static_def_no_type_math1Func.P;
p << remove_static_def_no_type_math1Func.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_math1Func@
F << remove_static_decl_with_type_math1Func.F;
T << remove_static_decl_with_type_math1Func.T;
P << remove_static_decl_with_type_math1Func.P;
p << remove_static_decl_with_type_math1Func.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_math1Func@
F << remove_static_inline_math1Func.F;
T << remove_static_inline_math1Func.T;
P << remove_static_inline_math1Func.P;
p << remove_static_inline_math1Func.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: math2Func
@remove_static_def_brace_same_line_math2Func@
identifier F = { math2Func };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_math2Func@
identifier F = { math2Func };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_math2Func@
identifier F = { math2Func };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_math2Func@
identifier F = { math2Func };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_math2Func@
identifier F = { math2Func };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_math2Func@
F << remove_static_def_brace_same_line_math2Func.F;
T << remove_static_def_brace_same_line_math2Func.T;
P << remove_static_def_brace_same_line_math2Func.P;
p << remove_static_def_brace_same_line_math2Func.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_math2Func@
F << remove_static_def_brace_next_line_math2Func.F;
T << remove_static_def_brace_next_line_math2Func.T;
P << remove_static_def_brace_next_line_math2Func.P;
p << remove_static_def_brace_next_line_math2Func.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_math2Func@
F << remove_static_def_no_type_math2Func.F;
P << remove_static_def_no_type_math2Func.P;
p << remove_static_def_no_type_math2Func.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_math2Func@
F << remove_static_decl_with_type_math2Func.F;
T << remove_static_decl_with_type_math2Func.T;
P << remove_static_decl_with_type_math2Func.P;
p << remove_static_decl_with_type_math2Func.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_math2Func@
F << remove_static_inline_math2Func.F;
T << remove_static_inline_math2Func.T;
P << remove_static_inline_math2Func.P;
p << remove_static_inline_math2Func.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: memjrnlClose
@remove_static_def_brace_same_line_memjrnlClose@
identifier F = { memjrnlClose };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_memjrnlClose@
identifier F = { memjrnlClose };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_memjrnlClose@
identifier F = { memjrnlClose };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_memjrnlClose@
identifier F = { memjrnlClose };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_memjrnlClose@
identifier F = { memjrnlClose };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_memjrnlClose@
F << remove_static_def_brace_same_line_memjrnlClose.F;
T << remove_static_def_brace_same_line_memjrnlClose.T;
P << remove_static_def_brace_same_line_memjrnlClose.P;
p << remove_static_def_brace_same_line_memjrnlClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_memjrnlClose@
F << remove_static_def_brace_next_line_memjrnlClose.F;
T << remove_static_def_brace_next_line_memjrnlClose.T;
P << remove_static_def_brace_next_line_memjrnlClose.P;
p << remove_static_def_brace_next_line_memjrnlClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_memjrnlClose@
F << remove_static_def_no_type_memjrnlClose.F;
P << remove_static_def_no_type_memjrnlClose.P;
p << remove_static_def_no_type_memjrnlClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_memjrnlClose@
F << remove_static_decl_with_type_memjrnlClose.F;
T << remove_static_decl_with_type_memjrnlClose.T;
P << remove_static_decl_with_type_memjrnlClose.P;
p << remove_static_decl_with_type_memjrnlClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_memjrnlClose@
F << remove_static_inline_memjrnlClose.F;
T << remove_static_inline_memjrnlClose.T;
P << remove_static_inline_memjrnlClose.P;
p << remove_static_inline_memjrnlClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: memjrnlTruncate
@remove_static_def_brace_same_line_memjrnlTruncate@
identifier F = { memjrnlTruncate };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_memjrnlTruncate@
identifier F = { memjrnlTruncate };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_memjrnlTruncate@
identifier F = { memjrnlTruncate };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_memjrnlTruncate@
identifier F = { memjrnlTruncate };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_memjrnlTruncate@
identifier F = { memjrnlTruncate };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_memjrnlTruncate@
F << remove_static_def_brace_same_line_memjrnlTruncate.F;
T << remove_static_def_brace_same_line_memjrnlTruncate.T;
P << remove_static_def_brace_same_line_memjrnlTruncate.P;
p << remove_static_def_brace_same_line_memjrnlTruncate.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_memjrnlTruncate@
F << remove_static_def_brace_next_line_memjrnlTruncate.F;
T << remove_static_def_brace_next_line_memjrnlTruncate.T;
P << remove_static_def_brace_next_line_memjrnlTruncate.P;
p << remove_static_def_brace_next_line_memjrnlTruncate.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_memjrnlTruncate@
F << remove_static_def_no_type_memjrnlTruncate.F;
P << remove_static_def_no_type_memjrnlTruncate.P;
p << remove_static_def_no_type_memjrnlTruncate.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_memjrnlTruncate@
F << remove_static_decl_with_type_memjrnlTruncate.F;
T << remove_static_decl_with_type_memjrnlTruncate.T;
P << remove_static_decl_with_type_memjrnlTruncate.P;
p << remove_static_decl_with_type_memjrnlTruncate.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_memjrnlTruncate@
F << remove_static_inline_memjrnlTruncate.F;
T << remove_static_inline_memjrnlTruncate.T;
P << remove_static_inline_memjrnlTruncate.P;
p << remove_static_inline_memjrnlTruncate.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: memjrnlWrite
@remove_static_def_brace_same_line_memjrnlWrite@
identifier F = { memjrnlWrite };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_memjrnlWrite@
identifier F = { memjrnlWrite };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_memjrnlWrite@
identifier F = { memjrnlWrite };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_memjrnlWrite@
identifier F = { memjrnlWrite };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_memjrnlWrite@
identifier F = { memjrnlWrite };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_memjrnlWrite@
F << remove_static_def_brace_same_line_memjrnlWrite.F;
T << remove_static_def_brace_same_line_memjrnlWrite.T;
P << remove_static_def_brace_same_line_memjrnlWrite.P;
p << remove_static_def_brace_same_line_memjrnlWrite.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_memjrnlWrite@
F << remove_static_def_brace_next_line_memjrnlWrite.F;
T << remove_static_def_brace_next_line_memjrnlWrite.T;
P << remove_static_def_brace_next_line_memjrnlWrite.P;
p << remove_static_def_brace_next_line_memjrnlWrite.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_memjrnlWrite@
F << remove_static_def_no_type_memjrnlWrite.F;
P << remove_static_def_no_type_memjrnlWrite.P;
p << remove_static_def_no_type_memjrnlWrite.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_memjrnlWrite@
F << remove_static_decl_with_type_memjrnlWrite.F;
T << remove_static_decl_with_type_memjrnlWrite.T;
P << remove_static_decl_with_type_memjrnlWrite.P;
p << remove_static_decl_with_type_memjrnlWrite.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_memjrnlWrite@
F << remove_static_inline_memjrnlWrite.F;
T << remove_static_inline_memjrnlWrite.T;
P << remove_static_inline_memjrnlWrite.P;
p << remove_static_inline_memjrnlWrite.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: minMaxFinalize
@remove_static_def_brace_same_line_minMaxFinalize@
identifier F = { minMaxFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_minMaxFinalize@
identifier F = { minMaxFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_minMaxFinalize@
identifier F = { minMaxFinalize };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_minMaxFinalize@
identifier F = { minMaxFinalize };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_minMaxFinalize@
identifier F = { minMaxFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_minMaxFinalize@
F << remove_static_def_brace_same_line_minMaxFinalize.F;
T << remove_static_def_brace_same_line_minMaxFinalize.T;
P << remove_static_def_brace_same_line_minMaxFinalize.P;
p << remove_static_def_brace_same_line_minMaxFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_minMaxFinalize@
F << remove_static_def_brace_next_line_minMaxFinalize.F;
T << remove_static_def_brace_next_line_minMaxFinalize.T;
P << remove_static_def_brace_next_line_minMaxFinalize.P;
p << remove_static_def_brace_next_line_minMaxFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_minMaxFinalize@
F << remove_static_def_no_type_minMaxFinalize.F;
P << remove_static_def_no_type_minMaxFinalize.P;
p << remove_static_def_no_type_minMaxFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_minMaxFinalize@
F << remove_static_decl_with_type_minMaxFinalize.F;
T << remove_static_decl_with_type_minMaxFinalize.T;
P << remove_static_decl_with_type_minMaxFinalize.P;
p << remove_static_decl_with_type_minMaxFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_minMaxFinalize@
F << remove_static_inline_minMaxFinalize.F;
T << remove_static_inline_minMaxFinalize.T;
P << remove_static_inline_minMaxFinalize.P;
p << remove_static_inline_minMaxFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: minmaxStep
@remove_static_def_brace_same_line_minmaxStep@
identifier F = { minmaxStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_minmaxStep@
identifier F = { minmaxStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_minmaxStep@
identifier F = { minmaxStep };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_minmaxStep@
identifier F = { minmaxStep };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_minmaxStep@
identifier F = { minmaxStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_minmaxStep@
F << remove_static_def_brace_same_line_minmaxStep.F;
T << remove_static_def_brace_same_line_minmaxStep.T;
P << remove_static_def_brace_same_line_minmaxStep.P;
p << remove_static_def_brace_same_line_minmaxStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_minmaxStep@
F << remove_static_def_brace_next_line_minmaxStep.F;
T << remove_static_def_brace_next_line_minmaxStep.T;
P << remove_static_def_brace_next_line_minmaxStep.P;
p << remove_static_def_brace_next_line_minmaxStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_minmaxStep@
F << remove_static_def_no_type_minmaxStep.F;
P << remove_static_def_no_type_minmaxStep.P;
p << remove_static_def_no_type_minmaxStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_minmaxStep@
F << remove_static_decl_with_type_minmaxStep.F;
T << remove_static_decl_with_type_minmaxStep.T;
P << remove_static_decl_with_type_minmaxStep.P;
p << remove_static_decl_with_type_minmaxStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_minmaxStep@
F << remove_static_inline_minmaxStep.F;
T << remove_static_inline_minmaxStep.T;
P << remove_static_inline_minmaxStep.P;
p << remove_static_inline_minmaxStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: nolockClose
@remove_static_def_brace_same_line_nolockClose@
identifier F = { nolockClose };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_nolockClose@
identifier F = { nolockClose };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_nolockClose@
identifier F = { nolockClose };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_nolockClose@
identifier F = { nolockClose };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_nolockClose@
identifier F = { nolockClose };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_nolockClose@
F << remove_static_def_brace_same_line_nolockClose.F;
T << remove_static_def_brace_same_line_nolockClose.T;
P << remove_static_def_brace_same_line_nolockClose.P;
p << remove_static_def_brace_same_line_nolockClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_nolockClose@
F << remove_static_def_brace_next_line_nolockClose.F;
T << remove_static_def_brace_next_line_nolockClose.T;
P << remove_static_def_brace_next_line_nolockClose.P;
p << remove_static_def_brace_next_line_nolockClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_nolockClose@
F << remove_static_def_no_type_nolockClose.F;
P << remove_static_def_no_type_nolockClose.P;
p << remove_static_def_no_type_nolockClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_nolockClose@
F << remove_static_decl_with_type_nolockClose.F;
T << remove_static_decl_with_type_nolockClose.T;
P << remove_static_decl_with_type_nolockClose.P;
p << remove_static_decl_with_type_nolockClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_nolockClose@
F << remove_static_inline_nolockClose.F;
T << remove_static_inline_nolockClose.T;
P << remove_static_inline_nolockClose.P;
p << remove_static_inline_nolockClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: noopMutexAlloc
@remove_static_def_brace_same_line_noopMutexAlloc@
identifier F = { noopMutexAlloc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_noopMutexAlloc@
identifier F = { noopMutexAlloc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_noopMutexAlloc@
identifier F = { noopMutexAlloc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_noopMutexAlloc@
identifier F = { noopMutexAlloc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_noopMutexAlloc@
identifier F = { noopMutexAlloc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_noopMutexAlloc@
F << remove_static_def_brace_same_line_noopMutexAlloc.F;
T << remove_static_def_brace_same_line_noopMutexAlloc.T;
P << remove_static_def_brace_same_line_noopMutexAlloc.P;
p << remove_static_def_brace_same_line_noopMutexAlloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_noopMutexAlloc@
F << remove_static_def_brace_next_line_noopMutexAlloc.F;
T << remove_static_def_brace_next_line_noopMutexAlloc.T;
P << remove_static_def_brace_next_line_noopMutexAlloc.P;
p << remove_static_def_brace_next_line_noopMutexAlloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_noopMutexAlloc@
F << remove_static_def_no_type_noopMutexAlloc.F;
P << remove_static_def_no_type_noopMutexAlloc.P;
p << remove_static_def_no_type_noopMutexAlloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_noopMutexAlloc@
F << remove_static_decl_with_type_noopMutexAlloc.F;
T << remove_static_decl_with_type_noopMutexAlloc.T;
P << remove_static_decl_with_type_noopMutexAlloc.P;
p << remove_static_decl_with_type_noopMutexAlloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_noopMutexAlloc@
F << remove_static_inline_noopMutexAlloc.F;
T << remove_static_inline_noopMutexAlloc.T;
P << remove_static_inline_noopMutexAlloc.P;
p << remove_static_inline_noopMutexAlloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: noopMutexEnd
@remove_static_def_brace_same_line_noopMutexEnd@
identifier F = { noopMutexEnd };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_noopMutexEnd@
identifier F = { noopMutexEnd };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_noopMutexEnd@
identifier F = { noopMutexEnd };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_noopMutexEnd@
identifier F = { noopMutexEnd };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_noopMutexEnd@
identifier F = { noopMutexEnd };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_noopMutexEnd@
F << remove_static_def_brace_same_line_noopMutexEnd.F;
T << remove_static_def_brace_same_line_noopMutexEnd.T;
P << remove_static_def_brace_same_line_noopMutexEnd.P;
p << remove_static_def_brace_same_line_noopMutexEnd.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_noopMutexEnd@
F << remove_static_def_brace_next_line_noopMutexEnd.F;
T << remove_static_def_brace_next_line_noopMutexEnd.T;
P << remove_static_def_brace_next_line_noopMutexEnd.P;
p << remove_static_def_brace_next_line_noopMutexEnd.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_noopMutexEnd@
F << remove_static_def_no_type_noopMutexEnd.F;
P << remove_static_def_no_type_noopMutexEnd.P;
p << remove_static_def_no_type_noopMutexEnd.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_noopMutexEnd@
F << remove_static_decl_with_type_noopMutexEnd.F;
T << remove_static_decl_with_type_noopMutexEnd.T;
P << remove_static_decl_with_type_noopMutexEnd.P;
p << remove_static_decl_with_type_noopMutexEnd.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_noopMutexEnd@
F << remove_static_inline_noopMutexEnd.F;
T << remove_static_inline_noopMutexEnd.T;
P << remove_static_inline_noopMutexEnd.P;
p << remove_static_inline_noopMutexEnd.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: noopMutexEnter
@remove_static_def_brace_same_line_noopMutexEnter@
identifier F = { noopMutexEnter };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_noopMutexEnter@
identifier F = { noopMutexEnter };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_noopMutexEnter@
identifier F = { noopMutexEnter };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_noopMutexEnter@
identifier F = { noopMutexEnter };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_noopMutexEnter@
identifier F = { noopMutexEnter };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_noopMutexEnter@
F << remove_static_def_brace_same_line_noopMutexEnter.F;
T << remove_static_def_brace_same_line_noopMutexEnter.T;
P << remove_static_def_brace_same_line_noopMutexEnter.P;
p << remove_static_def_brace_same_line_noopMutexEnter.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_noopMutexEnter@
F << remove_static_def_brace_next_line_noopMutexEnter.F;
T << remove_static_def_brace_next_line_noopMutexEnter.T;
P << remove_static_def_brace_next_line_noopMutexEnter.P;
p << remove_static_def_brace_next_line_noopMutexEnter.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_noopMutexEnter@
F << remove_static_def_no_type_noopMutexEnter.F;
P << remove_static_def_no_type_noopMutexEnter.P;
p << remove_static_def_no_type_noopMutexEnter.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_noopMutexEnter@
F << remove_static_decl_with_type_noopMutexEnter.F;
T << remove_static_decl_with_type_noopMutexEnter.T;
P << remove_static_decl_with_type_noopMutexEnter.P;
p << remove_static_decl_with_type_noopMutexEnter.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_noopMutexEnter@
F << remove_static_inline_noopMutexEnter.F;
T << remove_static_inline_noopMutexEnter.T;
P << remove_static_inline_noopMutexEnter.P;
p << remove_static_inline_noopMutexEnter.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: noopMutexFree
@remove_static_def_brace_same_line_noopMutexFree@
identifier F = { noopMutexFree };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_noopMutexFree@
identifier F = { noopMutexFree };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_noopMutexFree@
identifier F = { noopMutexFree };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_noopMutexFree@
identifier F = { noopMutexFree };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_noopMutexFree@
identifier F = { noopMutexFree };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_noopMutexFree@
F << remove_static_def_brace_same_line_noopMutexFree.F;
T << remove_static_def_brace_same_line_noopMutexFree.T;
P << remove_static_def_brace_same_line_noopMutexFree.P;
p << remove_static_def_brace_same_line_noopMutexFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_noopMutexFree@
F << remove_static_def_brace_next_line_noopMutexFree.F;
T << remove_static_def_brace_next_line_noopMutexFree.T;
P << remove_static_def_brace_next_line_noopMutexFree.P;
p << remove_static_def_brace_next_line_noopMutexFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_noopMutexFree@
F << remove_static_def_no_type_noopMutexFree.F;
P << remove_static_def_no_type_noopMutexFree.P;
p << remove_static_def_no_type_noopMutexFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_noopMutexFree@
F << remove_static_decl_with_type_noopMutexFree.F;
T << remove_static_decl_with_type_noopMutexFree.T;
P << remove_static_decl_with_type_noopMutexFree.P;
p << remove_static_decl_with_type_noopMutexFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_noopMutexFree@
F << remove_static_inline_noopMutexFree.F;
T << remove_static_inline_noopMutexFree.T;
P << remove_static_inline_noopMutexFree.P;
p << remove_static_inline_noopMutexFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: noopMutexInit
@remove_static_def_brace_same_line_noopMutexInit@
identifier F = { noopMutexInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_noopMutexInit@
identifier F = { noopMutexInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_noopMutexInit@
identifier F = { noopMutexInit };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_noopMutexInit@
identifier F = { noopMutexInit };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_noopMutexInit@
identifier F = { noopMutexInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_noopMutexInit@
F << remove_static_def_brace_same_line_noopMutexInit.F;
T << remove_static_def_brace_same_line_noopMutexInit.T;
P << remove_static_def_brace_same_line_noopMutexInit.P;
p << remove_static_def_brace_same_line_noopMutexInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_noopMutexInit@
F << remove_static_def_brace_next_line_noopMutexInit.F;
T << remove_static_def_brace_next_line_noopMutexInit.T;
P << remove_static_def_brace_next_line_noopMutexInit.P;
p << remove_static_def_brace_next_line_noopMutexInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_noopMutexInit@
F << remove_static_def_no_type_noopMutexInit.F;
P << remove_static_def_no_type_noopMutexInit.P;
p << remove_static_def_no_type_noopMutexInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_noopMutexInit@
F << remove_static_decl_with_type_noopMutexInit.F;
T << remove_static_decl_with_type_noopMutexInit.T;
P << remove_static_decl_with_type_noopMutexInit.P;
p << remove_static_decl_with_type_noopMutexInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_noopMutexInit@
F << remove_static_inline_noopMutexInit.F;
T << remove_static_inline_noopMutexInit.T;
P << remove_static_inline_noopMutexInit.P;
p << remove_static_inline_noopMutexInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: noopMutexLeave
@remove_static_def_brace_same_line_noopMutexLeave@
identifier F = { noopMutexLeave };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_noopMutexLeave@
identifier F = { noopMutexLeave };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_noopMutexLeave@
identifier F = { noopMutexLeave };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_noopMutexLeave@
identifier F = { noopMutexLeave };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_noopMutexLeave@
identifier F = { noopMutexLeave };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_noopMutexLeave@
F << remove_static_def_brace_same_line_noopMutexLeave.F;
T << remove_static_def_brace_same_line_noopMutexLeave.T;
P << remove_static_def_brace_same_line_noopMutexLeave.P;
p << remove_static_def_brace_same_line_noopMutexLeave.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_noopMutexLeave@
F << remove_static_def_brace_next_line_noopMutexLeave.F;
T << remove_static_def_brace_next_line_noopMutexLeave.T;
P << remove_static_def_brace_next_line_noopMutexLeave.P;
p << remove_static_def_brace_next_line_noopMutexLeave.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_noopMutexLeave@
F << remove_static_def_no_type_noopMutexLeave.F;
P << remove_static_def_no_type_noopMutexLeave.P;
p << remove_static_def_no_type_noopMutexLeave.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_noopMutexLeave@
F << remove_static_decl_with_type_noopMutexLeave.F;
T << remove_static_decl_with_type_noopMutexLeave.T;
P << remove_static_decl_with_type_noopMutexLeave.P;
p << remove_static_decl_with_type_noopMutexLeave.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_noopMutexLeave@
F << remove_static_inline_noopMutexLeave.F;
T << remove_static_inline_noopMutexLeave.T;
P << remove_static_inline_noopMutexLeave.P;
p << remove_static_inline_noopMutexLeave.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: noopMutexTry
@remove_static_def_brace_same_line_noopMutexTry@
identifier F = { noopMutexTry };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_noopMutexTry@
identifier F = { noopMutexTry };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_noopMutexTry@
identifier F = { noopMutexTry };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_noopMutexTry@
identifier F = { noopMutexTry };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_noopMutexTry@
identifier F = { noopMutexTry };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_noopMutexTry@
F << remove_static_def_brace_same_line_noopMutexTry.F;
T << remove_static_def_brace_same_line_noopMutexTry.T;
P << remove_static_def_brace_same_line_noopMutexTry.P;
p << remove_static_def_brace_same_line_noopMutexTry.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_noopMutexTry@
F << remove_static_def_brace_next_line_noopMutexTry.F;
T << remove_static_def_brace_next_line_noopMutexTry.T;
P << remove_static_def_brace_next_line_noopMutexTry.P;
p << remove_static_def_brace_next_line_noopMutexTry.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_noopMutexTry@
F << remove_static_def_no_type_noopMutexTry.F;
P << remove_static_def_no_type_noopMutexTry.P;
p << remove_static_def_no_type_noopMutexTry.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_noopMutexTry@
F << remove_static_decl_with_type_noopMutexTry.F;
T << remove_static_decl_with_type_noopMutexTry.T;
P << remove_static_decl_with_type_noopMutexTry.P;
p << remove_static_decl_with_type_noopMutexTry.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_noopMutexTry@
F << remove_static_inline_noopMutexTry.F;
T << remove_static_inline_noopMutexTry.T;
P << remove_static_inline_noopMutexTry.P;
p << remove_static_inline_noopMutexTry.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: noopValueFunc
@remove_static_def_brace_same_line_noopValueFunc@
identifier F = { noopValueFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_noopValueFunc@
identifier F = { noopValueFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_noopValueFunc@
identifier F = { noopValueFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_noopValueFunc@
identifier F = { noopValueFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_noopValueFunc@
identifier F = { noopValueFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_noopValueFunc@
F << remove_static_def_brace_same_line_noopValueFunc.F;
T << remove_static_def_brace_same_line_noopValueFunc.T;
P << remove_static_def_brace_same_line_noopValueFunc.P;
p << remove_static_def_brace_same_line_noopValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_noopValueFunc@
F << remove_static_def_brace_next_line_noopValueFunc.F;
T << remove_static_def_brace_next_line_noopValueFunc.T;
P << remove_static_def_brace_next_line_noopValueFunc.P;
p << remove_static_def_brace_next_line_noopValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_noopValueFunc@
F << remove_static_def_no_type_noopValueFunc.F;
P << remove_static_def_no_type_noopValueFunc.P;
p << remove_static_def_no_type_noopValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_noopValueFunc@
F << remove_static_decl_with_type_noopValueFunc.F;
T << remove_static_decl_with_type_noopValueFunc.T;
P << remove_static_decl_with_type_noopValueFunc.P;
p << remove_static_decl_with_type_noopValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_noopValueFunc@
F << remove_static_inline_noopValueFunc.F;
T << remove_static_inline_noopValueFunc.T;
P << remove_static_inline_noopValueFunc.P;
p << remove_static_inline_noopValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: nullifFunc
@remove_static_def_brace_same_line_nullifFunc@
identifier F = { nullifFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_nullifFunc@
identifier F = { nullifFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_nullifFunc@
identifier F = { nullifFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_nullifFunc@
identifier F = { nullifFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_nullifFunc@
identifier F = { nullifFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_nullifFunc@
F << remove_static_def_brace_same_line_nullifFunc.F;
T << remove_static_def_brace_same_line_nullifFunc.T;
P << remove_static_def_brace_same_line_nullifFunc.P;
p << remove_static_def_brace_same_line_nullifFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_nullifFunc@
F << remove_static_def_brace_next_line_nullifFunc.F;
T << remove_static_def_brace_next_line_nullifFunc.T;
P << remove_static_def_brace_next_line_nullifFunc.P;
p << remove_static_def_brace_next_line_nullifFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_nullifFunc@
F << remove_static_def_no_type_nullifFunc.F;
P << remove_static_def_no_type_nullifFunc.P;
p << remove_static_def_no_type_nullifFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_nullifFunc@
F << remove_static_decl_with_type_nullifFunc.F;
T << remove_static_decl_with_type_nullifFunc.T;
P << remove_static_decl_with_type_nullifFunc.P;
p << remove_static_decl_with_type_nullifFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_nullifFunc@
F << remove_static_inline_nullifFunc.F;
T << remove_static_inline_nullifFunc.T;
P << remove_static_inline_nullifFunc.P;
p << remove_static_inline_nullifFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: openDirectory
@remove_static_def_brace_same_line_openDirectory@
identifier F = { openDirectory };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_openDirectory@
identifier F = { openDirectory };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_openDirectory@
identifier F = { openDirectory };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_openDirectory@
identifier F = { openDirectory };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_openDirectory@
identifier F = { openDirectory };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_openDirectory@
F << remove_static_def_brace_same_line_openDirectory.F;
T << remove_static_def_brace_same_line_openDirectory.T;
P << remove_static_def_brace_same_line_openDirectory.P;
p << remove_static_def_brace_same_line_openDirectory.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_openDirectory@
F << remove_static_def_brace_next_line_openDirectory.F;
T << remove_static_def_brace_next_line_openDirectory.T;
P << remove_static_def_brace_next_line_openDirectory.P;
p << remove_static_def_brace_next_line_openDirectory.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_openDirectory@
F << remove_static_def_no_type_openDirectory.F;
P << remove_static_def_no_type_openDirectory.P;
p << remove_static_def_no_type_openDirectory.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_openDirectory@
F << remove_static_decl_with_type_openDirectory.F;
T << remove_static_decl_with_type_openDirectory.T;
P << remove_static_decl_with_type_openDirectory.P;
p << remove_static_decl_with_type_openDirectory.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_openDirectory@
F << remove_static_inline_openDirectory.F;
T << remove_static_inline_openDirectory.T;
P << remove_static_inline_openDirectory.P;
p << remove_static_inline_openDirectory.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pageReinit
@remove_static_def_brace_same_line_pageReinit@
identifier F = { pageReinit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pageReinit@
identifier F = { pageReinit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pageReinit@
identifier F = { pageReinit };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pageReinit@
identifier F = { pageReinit };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pageReinit@
identifier F = { pageReinit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pageReinit@
F << remove_static_def_brace_same_line_pageReinit.F;
T << remove_static_def_brace_same_line_pageReinit.T;
P << remove_static_def_brace_same_line_pageReinit.P;
p << remove_static_def_brace_same_line_pageReinit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pageReinit@
F << remove_static_def_brace_next_line_pageReinit.F;
T << remove_static_def_brace_next_line_pageReinit.T;
P << remove_static_def_brace_next_line_pageReinit.P;
p << remove_static_def_brace_next_line_pageReinit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pageReinit@
F << remove_static_def_no_type_pageReinit.F;
P << remove_static_def_no_type_pageReinit.P;
p << remove_static_def_no_type_pageReinit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pageReinit@
F << remove_static_decl_with_type_pageReinit.F;
T << remove_static_decl_with_type_pageReinit.T;
P << remove_static_decl_with_type_pageReinit.P;
p << remove_static_decl_with_type_pageReinit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pageReinit@
F << remove_static_inline_pageReinit.F;
T << remove_static_inline_pageReinit.T;
P << remove_static_inline_pageReinit.P;
p << remove_static_inline_pageReinit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pcache1Cachesize
@remove_static_def_brace_same_line_pcache1Cachesize@
identifier F = { pcache1Cachesize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pcache1Cachesize@
identifier F = { pcache1Cachesize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pcache1Cachesize@
identifier F = { pcache1Cachesize };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pcache1Cachesize@
identifier F = { pcache1Cachesize };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pcache1Cachesize@
identifier F = { pcache1Cachesize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pcache1Cachesize@
F << remove_static_def_brace_same_line_pcache1Cachesize.F;
T << remove_static_def_brace_same_line_pcache1Cachesize.T;
P << remove_static_def_brace_same_line_pcache1Cachesize.P;
p << remove_static_def_brace_same_line_pcache1Cachesize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pcache1Cachesize@
F << remove_static_def_brace_next_line_pcache1Cachesize.F;
T << remove_static_def_brace_next_line_pcache1Cachesize.T;
P << remove_static_def_brace_next_line_pcache1Cachesize.P;
p << remove_static_def_brace_next_line_pcache1Cachesize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pcache1Cachesize@
F << remove_static_def_no_type_pcache1Cachesize.F;
P << remove_static_def_no_type_pcache1Cachesize.P;
p << remove_static_def_no_type_pcache1Cachesize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pcache1Cachesize@
F << remove_static_decl_with_type_pcache1Cachesize.F;
T << remove_static_decl_with_type_pcache1Cachesize.T;
P << remove_static_decl_with_type_pcache1Cachesize.P;
p << remove_static_decl_with_type_pcache1Cachesize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pcache1Cachesize@
F << remove_static_inline_pcache1Cachesize.F;
T << remove_static_inline_pcache1Cachesize.T;
P << remove_static_inline_pcache1Cachesize.P;
p << remove_static_inline_pcache1Cachesize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pcache1Create
@remove_static_def_brace_same_line_pcache1Create@
identifier F = { pcache1Create };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pcache1Create@
identifier F = { pcache1Create };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pcache1Create@
identifier F = { pcache1Create };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pcache1Create@
identifier F = { pcache1Create };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pcache1Create@
identifier F = { pcache1Create };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pcache1Create@
F << remove_static_def_brace_same_line_pcache1Create.F;
T << remove_static_def_brace_same_line_pcache1Create.T;
P << remove_static_def_brace_same_line_pcache1Create.P;
p << remove_static_def_brace_same_line_pcache1Create.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pcache1Create@
F << remove_static_def_brace_next_line_pcache1Create.F;
T << remove_static_def_brace_next_line_pcache1Create.T;
P << remove_static_def_brace_next_line_pcache1Create.P;
p << remove_static_def_brace_next_line_pcache1Create.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pcache1Create@
F << remove_static_def_no_type_pcache1Create.F;
P << remove_static_def_no_type_pcache1Create.P;
p << remove_static_def_no_type_pcache1Create.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pcache1Create@
F << remove_static_decl_with_type_pcache1Create.F;
T << remove_static_decl_with_type_pcache1Create.T;
P << remove_static_decl_with_type_pcache1Create.P;
p << remove_static_decl_with_type_pcache1Create.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pcache1Create@
F << remove_static_inline_pcache1Create.F;
T << remove_static_inline_pcache1Create.T;
P << remove_static_inline_pcache1Create.P;
p << remove_static_inline_pcache1Create.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pcache1Destroy
@remove_static_def_brace_same_line_pcache1Destroy@
identifier F = { pcache1Destroy };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pcache1Destroy@
identifier F = { pcache1Destroy };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pcache1Destroy@
identifier F = { pcache1Destroy };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pcache1Destroy@
identifier F = { pcache1Destroy };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pcache1Destroy@
identifier F = { pcache1Destroy };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pcache1Destroy@
F << remove_static_def_brace_same_line_pcache1Destroy.F;
T << remove_static_def_brace_same_line_pcache1Destroy.T;
P << remove_static_def_brace_same_line_pcache1Destroy.P;
p << remove_static_def_brace_same_line_pcache1Destroy.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pcache1Destroy@
F << remove_static_def_brace_next_line_pcache1Destroy.F;
T << remove_static_def_brace_next_line_pcache1Destroy.T;
P << remove_static_def_brace_next_line_pcache1Destroy.P;
p << remove_static_def_brace_next_line_pcache1Destroy.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pcache1Destroy@
F << remove_static_def_no_type_pcache1Destroy.F;
P << remove_static_def_no_type_pcache1Destroy.P;
p << remove_static_def_no_type_pcache1Destroy.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pcache1Destroy@
F << remove_static_decl_with_type_pcache1Destroy.F;
T << remove_static_decl_with_type_pcache1Destroy.T;
P << remove_static_decl_with_type_pcache1Destroy.P;
p << remove_static_decl_with_type_pcache1Destroy.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pcache1Destroy@
F << remove_static_inline_pcache1Destroy.F;
T << remove_static_inline_pcache1Destroy.T;
P << remove_static_inline_pcache1Destroy.P;
p << remove_static_inline_pcache1Destroy.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pcache1Fetch
@remove_static_def_brace_same_line_pcache1Fetch@
identifier F = { pcache1Fetch };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pcache1Fetch@
identifier F = { pcache1Fetch };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pcache1Fetch@
identifier F = { pcache1Fetch };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pcache1Fetch@
identifier F = { pcache1Fetch };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pcache1Fetch@
identifier F = { pcache1Fetch };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pcache1Fetch@
F << remove_static_def_brace_same_line_pcache1Fetch.F;
T << remove_static_def_brace_same_line_pcache1Fetch.T;
P << remove_static_def_brace_same_line_pcache1Fetch.P;
p << remove_static_def_brace_same_line_pcache1Fetch.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pcache1Fetch@
F << remove_static_def_brace_next_line_pcache1Fetch.F;
T << remove_static_def_brace_next_line_pcache1Fetch.T;
P << remove_static_def_brace_next_line_pcache1Fetch.P;
p << remove_static_def_brace_next_line_pcache1Fetch.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pcache1Fetch@
F << remove_static_def_no_type_pcache1Fetch.F;
P << remove_static_def_no_type_pcache1Fetch.P;
p << remove_static_def_no_type_pcache1Fetch.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pcache1Fetch@
F << remove_static_decl_with_type_pcache1Fetch.F;
T << remove_static_decl_with_type_pcache1Fetch.T;
P << remove_static_decl_with_type_pcache1Fetch.P;
p << remove_static_decl_with_type_pcache1Fetch.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pcache1Fetch@
F << remove_static_inline_pcache1Fetch.F;
T << remove_static_inline_pcache1Fetch.T;
P << remove_static_inline_pcache1Fetch.P;
p << remove_static_inline_pcache1Fetch.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pcache1Init
@remove_static_def_brace_same_line_pcache1Init@
identifier F = { pcache1Init };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pcache1Init@
identifier F = { pcache1Init };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pcache1Init@
identifier F = { pcache1Init };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pcache1Init@
identifier F = { pcache1Init };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pcache1Init@
identifier F = { pcache1Init };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pcache1Init@
F << remove_static_def_brace_same_line_pcache1Init.F;
T << remove_static_def_brace_same_line_pcache1Init.T;
P << remove_static_def_brace_same_line_pcache1Init.P;
p << remove_static_def_brace_same_line_pcache1Init.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pcache1Init@
F << remove_static_def_brace_next_line_pcache1Init.F;
T << remove_static_def_brace_next_line_pcache1Init.T;
P << remove_static_def_brace_next_line_pcache1Init.P;
p << remove_static_def_brace_next_line_pcache1Init.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pcache1Init@
F << remove_static_def_no_type_pcache1Init.F;
P << remove_static_def_no_type_pcache1Init.P;
p << remove_static_def_no_type_pcache1Init.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pcache1Init@
F << remove_static_decl_with_type_pcache1Init.F;
T << remove_static_decl_with_type_pcache1Init.T;
P << remove_static_decl_with_type_pcache1Init.P;
p << remove_static_decl_with_type_pcache1Init.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pcache1Init@
F << remove_static_inline_pcache1Init.F;
T << remove_static_inline_pcache1Init.T;
P << remove_static_inline_pcache1Init.P;
p << remove_static_inline_pcache1Init.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pcache1Pagecount
@remove_static_def_brace_same_line_pcache1Pagecount@
identifier F = { pcache1Pagecount };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pcache1Pagecount@
identifier F = { pcache1Pagecount };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pcache1Pagecount@
identifier F = { pcache1Pagecount };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pcache1Pagecount@
identifier F = { pcache1Pagecount };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pcache1Pagecount@
identifier F = { pcache1Pagecount };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pcache1Pagecount@
F << remove_static_def_brace_same_line_pcache1Pagecount.F;
T << remove_static_def_brace_same_line_pcache1Pagecount.T;
P << remove_static_def_brace_same_line_pcache1Pagecount.P;
p << remove_static_def_brace_same_line_pcache1Pagecount.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pcache1Pagecount@
F << remove_static_def_brace_next_line_pcache1Pagecount.F;
T << remove_static_def_brace_next_line_pcache1Pagecount.T;
P << remove_static_def_brace_next_line_pcache1Pagecount.P;
p << remove_static_def_brace_next_line_pcache1Pagecount.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pcache1Pagecount@
F << remove_static_def_no_type_pcache1Pagecount.F;
P << remove_static_def_no_type_pcache1Pagecount.P;
p << remove_static_def_no_type_pcache1Pagecount.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pcache1Pagecount@
F << remove_static_decl_with_type_pcache1Pagecount.F;
T << remove_static_decl_with_type_pcache1Pagecount.T;
P << remove_static_decl_with_type_pcache1Pagecount.P;
p << remove_static_decl_with_type_pcache1Pagecount.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pcache1Pagecount@
F << remove_static_inline_pcache1Pagecount.F;
T << remove_static_inline_pcache1Pagecount.T;
P << remove_static_inline_pcache1Pagecount.P;
p << remove_static_inline_pcache1Pagecount.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pcache1Rekey
@remove_static_def_brace_same_line_pcache1Rekey@
identifier F = { pcache1Rekey };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pcache1Rekey@
identifier F = { pcache1Rekey };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pcache1Rekey@
identifier F = { pcache1Rekey };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pcache1Rekey@
identifier F = { pcache1Rekey };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pcache1Rekey@
identifier F = { pcache1Rekey };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pcache1Rekey@
F << remove_static_def_brace_same_line_pcache1Rekey.F;
T << remove_static_def_brace_same_line_pcache1Rekey.T;
P << remove_static_def_brace_same_line_pcache1Rekey.P;
p << remove_static_def_brace_same_line_pcache1Rekey.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pcache1Rekey@
F << remove_static_def_brace_next_line_pcache1Rekey.F;
T << remove_static_def_brace_next_line_pcache1Rekey.T;
P << remove_static_def_brace_next_line_pcache1Rekey.P;
p << remove_static_def_brace_next_line_pcache1Rekey.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pcache1Rekey@
F << remove_static_def_no_type_pcache1Rekey.F;
P << remove_static_def_no_type_pcache1Rekey.P;
p << remove_static_def_no_type_pcache1Rekey.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pcache1Rekey@
F << remove_static_decl_with_type_pcache1Rekey.F;
T << remove_static_decl_with_type_pcache1Rekey.T;
P << remove_static_decl_with_type_pcache1Rekey.P;
p << remove_static_decl_with_type_pcache1Rekey.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pcache1Rekey@
F << remove_static_inline_pcache1Rekey.F;
T << remove_static_inline_pcache1Rekey.T;
P << remove_static_inline_pcache1Rekey.P;
p << remove_static_inline_pcache1Rekey.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pcache1Shrink
@remove_static_def_brace_same_line_pcache1Shrink@
identifier F = { pcache1Shrink };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pcache1Shrink@
identifier F = { pcache1Shrink };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pcache1Shrink@
identifier F = { pcache1Shrink };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pcache1Shrink@
identifier F = { pcache1Shrink };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pcache1Shrink@
identifier F = { pcache1Shrink };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pcache1Shrink@
F << remove_static_def_brace_same_line_pcache1Shrink.F;
T << remove_static_def_brace_same_line_pcache1Shrink.T;
P << remove_static_def_brace_same_line_pcache1Shrink.P;
p << remove_static_def_brace_same_line_pcache1Shrink.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pcache1Shrink@
F << remove_static_def_brace_next_line_pcache1Shrink.F;
T << remove_static_def_brace_next_line_pcache1Shrink.T;
P << remove_static_def_brace_next_line_pcache1Shrink.P;
p << remove_static_def_brace_next_line_pcache1Shrink.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pcache1Shrink@
F << remove_static_def_no_type_pcache1Shrink.F;
P << remove_static_def_no_type_pcache1Shrink.P;
p << remove_static_def_no_type_pcache1Shrink.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pcache1Shrink@
F << remove_static_decl_with_type_pcache1Shrink.F;
T << remove_static_decl_with_type_pcache1Shrink.T;
P << remove_static_decl_with_type_pcache1Shrink.P;
p << remove_static_decl_with_type_pcache1Shrink.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pcache1Shrink@
F << remove_static_inline_pcache1Shrink.F;
T << remove_static_inline_pcache1Shrink.T;
P << remove_static_inline_pcache1Shrink.P;
p << remove_static_inline_pcache1Shrink.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pcache1Shutdown
@remove_static_def_brace_same_line_pcache1Shutdown@
identifier F = { pcache1Shutdown };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pcache1Shutdown@
identifier F = { pcache1Shutdown };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pcache1Shutdown@
identifier F = { pcache1Shutdown };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pcache1Shutdown@
identifier F = { pcache1Shutdown };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pcache1Shutdown@
identifier F = { pcache1Shutdown };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pcache1Shutdown@
F << remove_static_def_brace_same_line_pcache1Shutdown.F;
T << remove_static_def_brace_same_line_pcache1Shutdown.T;
P << remove_static_def_brace_same_line_pcache1Shutdown.P;
p << remove_static_def_brace_same_line_pcache1Shutdown.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pcache1Shutdown@
F << remove_static_def_brace_next_line_pcache1Shutdown.F;
T << remove_static_def_brace_next_line_pcache1Shutdown.T;
P << remove_static_def_brace_next_line_pcache1Shutdown.P;
p << remove_static_def_brace_next_line_pcache1Shutdown.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pcache1Shutdown@
F << remove_static_def_no_type_pcache1Shutdown.F;
P << remove_static_def_no_type_pcache1Shutdown.P;
p << remove_static_def_no_type_pcache1Shutdown.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pcache1Shutdown@
F << remove_static_decl_with_type_pcache1Shutdown.F;
T << remove_static_decl_with_type_pcache1Shutdown.T;
P << remove_static_decl_with_type_pcache1Shutdown.P;
p << remove_static_decl_with_type_pcache1Shutdown.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pcache1Shutdown@
F << remove_static_inline_pcache1Shutdown.F;
T << remove_static_inline_pcache1Shutdown.T;
P << remove_static_inline_pcache1Shutdown.P;
p << remove_static_inline_pcache1Shutdown.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pcache1Truncate
@remove_static_def_brace_same_line_pcache1Truncate@
identifier F = { pcache1Truncate };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pcache1Truncate@
identifier F = { pcache1Truncate };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pcache1Truncate@
identifier F = { pcache1Truncate };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pcache1Truncate@
identifier F = { pcache1Truncate };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pcache1Truncate@
identifier F = { pcache1Truncate };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pcache1Truncate@
F << remove_static_def_brace_same_line_pcache1Truncate.F;
T << remove_static_def_brace_same_line_pcache1Truncate.T;
P << remove_static_def_brace_same_line_pcache1Truncate.P;
p << remove_static_def_brace_same_line_pcache1Truncate.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pcache1Truncate@
F << remove_static_def_brace_next_line_pcache1Truncate.F;
T << remove_static_def_brace_next_line_pcache1Truncate.T;
P << remove_static_def_brace_next_line_pcache1Truncate.P;
p << remove_static_def_brace_next_line_pcache1Truncate.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pcache1Truncate@
F << remove_static_def_no_type_pcache1Truncate.F;
P << remove_static_def_no_type_pcache1Truncate.P;
p << remove_static_def_no_type_pcache1Truncate.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pcache1Truncate@
F << remove_static_decl_with_type_pcache1Truncate.F;
T << remove_static_decl_with_type_pcache1Truncate.T;
P << remove_static_decl_with_type_pcache1Truncate.P;
p << remove_static_decl_with_type_pcache1Truncate.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pcache1Truncate@
F << remove_static_inline_pcache1Truncate.F;
T << remove_static_inline_pcache1Truncate.T;
P << remove_static_inline_pcache1Truncate.P;
p << remove_static_inline_pcache1Truncate.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pcache1Unpin
@remove_static_def_brace_same_line_pcache1Unpin@
identifier F = { pcache1Unpin };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pcache1Unpin@
identifier F = { pcache1Unpin };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pcache1Unpin@
identifier F = { pcache1Unpin };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pcache1Unpin@
identifier F = { pcache1Unpin };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pcache1Unpin@
identifier F = { pcache1Unpin };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pcache1Unpin@
F << remove_static_def_brace_same_line_pcache1Unpin.F;
T << remove_static_def_brace_same_line_pcache1Unpin.T;
P << remove_static_def_brace_same_line_pcache1Unpin.P;
p << remove_static_def_brace_same_line_pcache1Unpin.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pcache1Unpin@
F << remove_static_def_brace_next_line_pcache1Unpin.F;
T << remove_static_def_brace_next_line_pcache1Unpin.T;
P << remove_static_def_brace_next_line_pcache1Unpin.P;
p << remove_static_def_brace_next_line_pcache1Unpin.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pcache1Unpin@
F << remove_static_def_no_type_pcache1Unpin.F;
P << remove_static_def_no_type_pcache1Unpin.P;
p << remove_static_def_no_type_pcache1Unpin.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pcache1Unpin@
F << remove_static_decl_with_type_pcache1Unpin.F;
T << remove_static_decl_with_type_pcache1Unpin.T;
P << remove_static_decl_with_type_pcache1Unpin.P;
p << remove_static_decl_with_type_pcache1Unpin.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pcache1Unpin@
F << remove_static_inline_pcache1Unpin.F;
T << remove_static_inline_pcache1Unpin.T;
P << remove_static_inline_pcache1Unpin.P;
p << remove_static_inline_pcache1Unpin.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: posixIoFinderImpl
@remove_static_def_brace_same_line_posixIoFinderImpl@
identifier F = { posixIoFinderImpl };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_posixIoFinderImpl@
identifier F = { posixIoFinderImpl };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_posixIoFinderImpl@
identifier F = { posixIoFinderImpl };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_posixIoFinderImpl@
identifier F = { posixIoFinderImpl };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_posixIoFinderImpl@
identifier F = { posixIoFinderImpl };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_posixIoFinderImpl@
F << remove_static_def_brace_same_line_posixIoFinderImpl.F;
T << remove_static_def_brace_same_line_posixIoFinderImpl.T;
P << remove_static_def_brace_same_line_posixIoFinderImpl.P;
p << remove_static_def_brace_same_line_posixIoFinderImpl.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_posixIoFinderImpl@
F << remove_static_def_brace_next_line_posixIoFinderImpl.F;
T << remove_static_def_brace_next_line_posixIoFinderImpl.T;
P << remove_static_def_brace_next_line_posixIoFinderImpl.P;
p << remove_static_def_brace_next_line_posixIoFinderImpl.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_posixIoFinderImpl@
F << remove_static_def_no_type_posixIoFinderImpl.F;
P << remove_static_def_no_type_posixIoFinderImpl.P;
p << remove_static_def_no_type_posixIoFinderImpl.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_posixIoFinderImpl@
F << remove_static_decl_with_type_posixIoFinderImpl.F;
T << remove_static_decl_with_type_posixIoFinderImpl.T;
P << remove_static_decl_with_type_posixIoFinderImpl.P;
p << remove_static_decl_with_type_posixIoFinderImpl.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_posixIoFinderImpl@
F << remove_static_inline_posixIoFinderImpl.F;
T << remove_static_inline_posixIoFinderImpl.T;
P << remove_static_inline_posixIoFinderImpl.P;
p << remove_static_inline_posixIoFinderImpl.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: posixOpen
@remove_static_def_brace_same_line_posixOpen@
identifier F = { posixOpen };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_posixOpen@
identifier F = { posixOpen };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_posixOpen@
identifier F = { posixOpen };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_posixOpen@
identifier F = { posixOpen };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_posixOpen@
identifier F = { posixOpen };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_posixOpen@
F << remove_static_def_brace_same_line_posixOpen.F;
T << remove_static_def_brace_same_line_posixOpen.T;
P << remove_static_def_brace_same_line_posixOpen.P;
p << remove_static_def_brace_same_line_posixOpen.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_posixOpen@
F << remove_static_def_brace_next_line_posixOpen.F;
T << remove_static_def_brace_next_line_posixOpen.T;
P << remove_static_def_brace_next_line_posixOpen.P;
p << remove_static_def_brace_next_line_posixOpen.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_posixOpen@
F << remove_static_def_no_type_posixOpen.F;
P << remove_static_def_no_type_posixOpen.P;
p << remove_static_def_no_type_posixOpen.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_posixOpen@
F << remove_static_decl_with_type_posixOpen.F;
T << remove_static_decl_with_type_posixOpen.T;
P << remove_static_decl_with_type_posixOpen.P;
p << remove_static_decl_with_type_posixOpen.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_posixOpen@
F << remove_static_inline_posixOpen.F;
T << remove_static_inline_posixOpen.T;
P << remove_static_inline_posixOpen.P;
p << remove_static_inline_posixOpen.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: printfFunc
@remove_static_def_brace_same_line_printfFunc@
identifier F = { printfFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_printfFunc@
identifier F = { printfFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_printfFunc@
identifier F = { printfFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_printfFunc@
identifier F = { printfFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_printfFunc@
identifier F = { printfFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_printfFunc@
F << remove_static_def_brace_same_line_printfFunc.F;
T << remove_static_def_brace_same_line_printfFunc.T;
P << remove_static_def_brace_same_line_printfFunc.P;
p << remove_static_def_brace_same_line_printfFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_printfFunc@
F << remove_static_def_brace_next_line_printfFunc.F;
T << remove_static_def_brace_next_line_printfFunc.T;
P << remove_static_def_brace_next_line_printfFunc.P;
p << remove_static_def_brace_next_line_printfFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_printfFunc@
F << remove_static_def_no_type_printfFunc.F;
P << remove_static_def_no_type_printfFunc.P;
p << remove_static_def_no_type_printfFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_printfFunc@
F << remove_static_decl_with_type_printfFunc.F;
T << remove_static_decl_with_type_printfFunc.T;
P << remove_static_decl_with_type_printfFunc.P;
p << remove_static_decl_with_type_printfFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_printfFunc@
F << remove_static_inline_printfFunc.F;
T << remove_static_inline_printfFunc.T;
P << remove_static_inline_printfFunc.P;
p << remove_static_inline_printfFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: propagateConstantExprRewrite
@remove_static_def_brace_same_line_propagateConstantExprRewrite@
identifier F = { propagateConstantExprRewrite };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_propagateConstantExprRewrite@
identifier F = { propagateConstantExprRewrite };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_propagateConstantExprRewrite@
identifier F = { propagateConstantExprRewrite };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_propagateConstantExprRewrite@
identifier F = { propagateConstantExprRewrite };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_propagateConstantExprRewrite@
identifier F = { propagateConstantExprRewrite };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_propagateConstantExprRewrite@
F << remove_static_def_brace_same_line_propagateConstantExprRewrite.F;
T << remove_static_def_brace_same_line_propagateConstantExprRewrite.T;
P << remove_static_def_brace_same_line_propagateConstantExprRewrite.P;
p << remove_static_def_brace_same_line_propagateConstantExprRewrite.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_propagateConstantExprRewrite@
F << remove_static_def_brace_next_line_propagateConstantExprRewrite.F;
T << remove_static_def_brace_next_line_propagateConstantExprRewrite.T;
P << remove_static_def_brace_next_line_propagateConstantExprRewrite.P;
p << remove_static_def_brace_next_line_propagateConstantExprRewrite.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_propagateConstantExprRewrite@
F << remove_static_def_no_type_propagateConstantExprRewrite.F;
P << remove_static_def_no_type_propagateConstantExprRewrite.P;
p << remove_static_def_no_type_propagateConstantExprRewrite.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_propagateConstantExprRewrite@
F << remove_static_decl_with_type_propagateConstantExprRewrite.F;
T << remove_static_decl_with_type_propagateConstantExprRewrite.T;
P << remove_static_decl_with_type_propagateConstantExprRewrite.P;
p << remove_static_decl_with_type_propagateConstantExprRewrite.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_propagateConstantExprRewrite@
F << remove_static_inline_propagateConstantExprRewrite.F;
T << remove_static_inline_propagateConstantExprRewrite.T;
P << remove_static_inline_propagateConstantExprRewrite.P;
p << remove_static_inline_propagateConstantExprRewrite.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pthreadMutexAlloc
@remove_static_def_brace_same_line_pthreadMutexAlloc@
identifier F = { pthreadMutexAlloc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pthreadMutexAlloc@
identifier F = { pthreadMutexAlloc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pthreadMutexAlloc@
identifier F = { pthreadMutexAlloc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pthreadMutexAlloc@
identifier F = { pthreadMutexAlloc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pthreadMutexAlloc@
identifier F = { pthreadMutexAlloc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pthreadMutexAlloc@
F << remove_static_def_brace_same_line_pthreadMutexAlloc.F;
T << remove_static_def_brace_same_line_pthreadMutexAlloc.T;
P << remove_static_def_brace_same_line_pthreadMutexAlloc.P;
p << remove_static_def_brace_same_line_pthreadMutexAlloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pthreadMutexAlloc@
F << remove_static_def_brace_next_line_pthreadMutexAlloc.F;
T << remove_static_def_brace_next_line_pthreadMutexAlloc.T;
P << remove_static_def_brace_next_line_pthreadMutexAlloc.P;
p << remove_static_def_brace_next_line_pthreadMutexAlloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pthreadMutexAlloc@
F << remove_static_def_no_type_pthreadMutexAlloc.F;
P << remove_static_def_no_type_pthreadMutexAlloc.P;
p << remove_static_def_no_type_pthreadMutexAlloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pthreadMutexAlloc@
F << remove_static_decl_with_type_pthreadMutexAlloc.F;
T << remove_static_decl_with_type_pthreadMutexAlloc.T;
P << remove_static_decl_with_type_pthreadMutexAlloc.P;
p << remove_static_decl_with_type_pthreadMutexAlloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pthreadMutexAlloc@
F << remove_static_inline_pthreadMutexAlloc.F;
T << remove_static_inline_pthreadMutexAlloc.T;
P << remove_static_inline_pthreadMutexAlloc.P;
p << remove_static_inline_pthreadMutexAlloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pthreadMutexEnter
@remove_static_def_brace_same_line_pthreadMutexEnter@
identifier F = { pthreadMutexEnter };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pthreadMutexEnter@
identifier F = { pthreadMutexEnter };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pthreadMutexEnter@
identifier F = { pthreadMutexEnter };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pthreadMutexEnter@
identifier F = { pthreadMutexEnter };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pthreadMutexEnter@
identifier F = { pthreadMutexEnter };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pthreadMutexEnter@
F << remove_static_def_brace_same_line_pthreadMutexEnter.F;
T << remove_static_def_brace_same_line_pthreadMutexEnter.T;
P << remove_static_def_brace_same_line_pthreadMutexEnter.P;
p << remove_static_def_brace_same_line_pthreadMutexEnter.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pthreadMutexEnter@
F << remove_static_def_brace_next_line_pthreadMutexEnter.F;
T << remove_static_def_brace_next_line_pthreadMutexEnter.T;
P << remove_static_def_brace_next_line_pthreadMutexEnter.P;
p << remove_static_def_brace_next_line_pthreadMutexEnter.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pthreadMutexEnter@
F << remove_static_def_no_type_pthreadMutexEnter.F;
P << remove_static_def_no_type_pthreadMutexEnter.P;
p << remove_static_def_no_type_pthreadMutexEnter.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pthreadMutexEnter@
F << remove_static_decl_with_type_pthreadMutexEnter.F;
T << remove_static_decl_with_type_pthreadMutexEnter.T;
P << remove_static_decl_with_type_pthreadMutexEnter.P;
p << remove_static_decl_with_type_pthreadMutexEnter.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pthreadMutexEnter@
F << remove_static_inline_pthreadMutexEnter.F;
T << remove_static_inline_pthreadMutexEnter.T;
P << remove_static_inline_pthreadMutexEnter.P;
p << remove_static_inline_pthreadMutexEnter.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pthreadMutexFree
@remove_static_def_brace_same_line_pthreadMutexFree@
identifier F = { pthreadMutexFree };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pthreadMutexFree@
identifier F = { pthreadMutexFree };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pthreadMutexFree@
identifier F = { pthreadMutexFree };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pthreadMutexFree@
identifier F = { pthreadMutexFree };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pthreadMutexFree@
identifier F = { pthreadMutexFree };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pthreadMutexFree@
F << remove_static_def_brace_same_line_pthreadMutexFree.F;
T << remove_static_def_brace_same_line_pthreadMutexFree.T;
P << remove_static_def_brace_same_line_pthreadMutexFree.P;
p << remove_static_def_brace_same_line_pthreadMutexFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pthreadMutexFree@
F << remove_static_def_brace_next_line_pthreadMutexFree.F;
T << remove_static_def_brace_next_line_pthreadMutexFree.T;
P << remove_static_def_brace_next_line_pthreadMutexFree.P;
p << remove_static_def_brace_next_line_pthreadMutexFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pthreadMutexFree@
F << remove_static_def_no_type_pthreadMutexFree.F;
P << remove_static_def_no_type_pthreadMutexFree.P;
p << remove_static_def_no_type_pthreadMutexFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pthreadMutexFree@
F << remove_static_decl_with_type_pthreadMutexFree.F;
T << remove_static_decl_with_type_pthreadMutexFree.T;
P << remove_static_decl_with_type_pthreadMutexFree.P;
p << remove_static_decl_with_type_pthreadMutexFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pthreadMutexFree@
F << remove_static_inline_pthreadMutexFree.F;
T << remove_static_inline_pthreadMutexFree.T;
P << remove_static_inline_pthreadMutexFree.P;
p << remove_static_inline_pthreadMutexFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pthreadMutexInit
@remove_static_def_brace_same_line_pthreadMutexInit@
identifier F = { pthreadMutexInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pthreadMutexInit@
identifier F = { pthreadMutexInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pthreadMutexInit@
identifier F = { pthreadMutexInit };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pthreadMutexInit@
identifier F = { pthreadMutexInit };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pthreadMutexInit@
identifier F = { pthreadMutexInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pthreadMutexInit@
F << remove_static_def_brace_same_line_pthreadMutexInit.F;
T << remove_static_def_brace_same_line_pthreadMutexInit.T;
P << remove_static_def_brace_same_line_pthreadMutexInit.P;
p << remove_static_def_brace_same_line_pthreadMutexInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pthreadMutexInit@
F << remove_static_def_brace_next_line_pthreadMutexInit.F;
T << remove_static_def_brace_next_line_pthreadMutexInit.T;
P << remove_static_def_brace_next_line_pthreadMutexInit.P;
p << remove_static_def_brace_next_line_pthreadMutexInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pthreadMutexInit@
F << remove_static_def_no_type_pthreadMutexInit.F;
P << remove_static_def_no_type_pthreadMutexInit.P;
p << remove_static_def_no_type_pthreadMutexInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pthreadMutexInit@
F << remove_static_decl_with_type_pthreadMutexInit.F;
T << remove_static_decl_with_type_pthreadMutexInit.T;
P << remove_static_decl_with_type_pthreadMutexInit.P;
p << remove_static_decl_with_type_pthreadMutexInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pthreadMutexInit@
F << remove_static_inline_pthreadMutexInit.F;
T << remove_static_inline_pthreadMutexInit.T;
P << remove_static_inline_pthreadMutexInit.P;
p << remove_static_inline_pthreadMutexInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: pthreadMutexLeave
@remove_static_def_brace_same_line_pthreadMutexLeave@
identifier F = { pthreadMutexLeave };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_pthreadMutexLeave@
identifier F = { pthreadMutexLeave };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_pthreadMutexLeave@
identifier F = { pthreadMutexLeave };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_pthreadMutexLeave@
identifier F = { pthreadMutexLeave };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_pthreadMutexLeave@
identifier F = { pthreadMutexLeave };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_pthreadMutexLeave@
F << remove_static_def_brace_same_line_pthreadMutexLeave.F;
T << remove_static_def_brace_same_line_pthreadMutexLeave.T;
P << remove_static_def_brace_same_line_pthreadMutexLeave.P;
p << remove_static_def_brace_same_line_pthreadMutexLeave.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_pthreadMutexLeave@
F << remove_static_def_brace_next_line_pthreadMutexLeave.F;
T << remove_static_def_brace_next_line_pthreadMutexLeave.T;
P << remove_static_def_brace_next_line_pthreadMutexLeave.P;
p << remove_static_def_brace_next_line_pthreadMutexLeave.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_pthreadMutexLeave@
F << remove_static_def_no_type_pthreadMutexLeave.F;
P << remove_static_def_no_type_pthreadMutexLeave.P;
p << remove_static_def_no_type_pthreadMutexLeave.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_pthreadMutexLeave@
F << remove_static_decl_with_type_pthreadMutexLeave.F;
T << remove_static_decl_with_type_pthreadMutexLeave.T;
P << remove_static_decl_with_type_pthreadMutexLeave.P;
p << remove_static_decl_with_type_pthreadMutexLeave.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_pthreadMutexLeave@
F << remove_static_inline_pthreadMutexLeave.F;
T << remove_static_inline_pthreadMutexLeave.T;
P << remove_static_inline_pthreadMutexLeave.P;
p << remove_static_inline_pthreadMutexLeave.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: quoteFunc
@remove_static_def_brace_same_line_quoteFunc@
identifier F = { quoteFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_quoteFunc@
identifier F = { quoteFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_quoteFunc@
identifier F = { quoteFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_quoteFunc@
identifier F = { quoteFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_quoteFunc@
identifier F = { quoteFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_quoteFunc@
F << remove_static_def_brace_same_line_quoteFunc.F;
T << remove_static_def_brace_same_line_quoteFunc.T;
P << remove_static_def_brace_same_line_quoteFunc.P;
p << remove_static_def_brace_same_line_quoteFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_quoteFunc@
F << remove_static_def_brace_next_line_quoteFunc.F;
T << remove_static_def_brace_next_line_quoteFunc.T;
P << remove_static_def_brace_next_line_quoteFunc.P;
p << remove_static_def_brace_next_line_quoteFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_quoteFunc@
F << remove_static_def_no_type_quoteFunc.F;
P << remove_static_def_no_type_quoteFunc.P;
p << remove_static_def_no_type_quoteFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_quoteFunc@
F << remove_static_decl_with_type_quoteFunc.F;
T << remove_static_decl_with_type_quoteFunc.T;
P << remove_static_decl_with_type_quoteFunc.P;
p << remove_static_decl_with_type_quoteFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_quoteFunc@
F << remove_static_inline_quoteFunc.F;
T << remove_static_inline_quoteFunc.T;
P << remove_static_inline_quoteFunc.P;
p << remove_static_inline_quoteFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: randomBlob
@remove_static_def_brace_same_line_randomBlob@
identifier F = { randomBlob };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_randomBlob@
identifier F = { randomBlob };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_randomBlob@
identifier F = { randomBlob };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_randomBlob@
identifier F = { randomBlob };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_randomBlob@
identifier F = { randomBlob };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_randomBlob@
F << remove_static_def_brace_same_line_randomBlob.F;
T << remove_static_def_brace_same_line_randomBlob.T;
P << remove_static_def_brace_same_line_randomBlob.P;
p << remove_static_def_brace_same_line_randomBlob.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_randomBlob@
F << remove_static_def_brace_next_line_randomBlob.F;
T << remove_static_def_brace_next_line_randomBlob.T;
P << remove_static_def_brace_next_line_randomBlob.P;
p << remove_static_def_brace_next_line_randomBlob.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_randomBlob@
F << remove_static_def_no_type_randomBlob.F;
P << remove_static_def_no_type_randomBlob.P;
p << remove_static_def_no_type_randomBlob.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_randomBlob@
F << remove_static_decl_with_type_randomBlob.F;
T << remove_static_decl_with_type_randomBlob.T;
P << remove_static_decl_with_type_randomBlob.P;
p << remove_static_decl_with_type_randomBlob.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_randomBlob@
F << remove_static_inline_randomBlob.F;
T << remove_static_inline_randomBlob.T;
P << remove_static_inline_randomBlob.P;
p << remove_static_inline_randomBlob.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: rankStepFunc
@remove_static_def_brace_same_line_rankStepFunc@
identifier F = { rankStepFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_rankStepFunc@
identifier F = { rankStepFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_rankStepFunc@
identifier F = { rankStepFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_rankStepFunc@
identifier F = { rankStepFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_rankStepFunc@
identifier F = { rankStepFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_rankStepFunc@
F << remove_static_def_brace_same_line_rankStepFunc.F;
T << remove_static_def_brace_same_line_rankStepFunc.T;
P << remove_static_def_brace_same_line_rankStepFunc.P;
p << remove_static_def_brace_same_line_rankStepFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_rankStepFunc@
F << remove_static_def_brace_next_line_rankStepFunc.F;
T << remove_static_def_brace_next_line_rankStepFunc.T;
P << remove_static_def_brace_next_line_rankStepFunc.P;
p << remove_static_def_brace_next_line_rankStepFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_rankStepFunc@
F << remove_static_def_no_type_rankStepFunc.F;
P << remove_static_def_no_type_rankStepFunc.P;
p << remove_static_def_no_type_rankStepFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_rankStepFunc@
F << remove_static_decl_with_type_rankStepFunc.F;
T << remove_static_decl_with_type_rankStepFunc.T;
P << remove_static_decl_with_type_rankStepFunc.P;
p << remove_static_decl_with_type_rankStepFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_rankStepFunc@
F << remove_static_inline_rankStepFunc.F;
T << remove_static_inline_rankStepFunc.T;
P << remove_static_inline_rankStepFunc.P;
p << remove_static_inline_rankStepFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: rankValueFunc
@remove_static_def_brace_same_line_rankValueFunc@
identifier F = { rankValueFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_rankValueFunc@
identifier F = { rankValueFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_rankValueFunc@
identifier F = { rankValueFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_rankValueFunc@
identifier F = { rankValueFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_rankValueFunc@
identifier F = { rankValueFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_rankValueFunc@
F << remove_static_def_brace_same_line_rankValueFunc.F;
T << remove_static_def_brace_same_line_rankValueFunc.T;
P << remove_static_def_brace_same_line_rankValueFunc.P;
p << remove_static_def_brace_same_line_rankValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_rankValueFunc@
F << remove_static_def_brace_next_line_rankValueFunc.F;
T << remove_static_def_brace_next_line_rankValueFunc.T;
P << remove_static_def_brace_next_line_rankValueFunc.P;
p << remove_static_def_brace_next_line_rankValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_rankValueFunc@
F << remove_static_def_no_type_rankValueFunc.F;
P << remove_static_def_no_type_rankValueFunc.P;
p << remove_static_def_no_type_rankValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_rankValueFunc@
F << remove_static_decl_with_type_rankValueFunc.F;
T << remove_static_decl_with_type_rankValueFunc.T;
P << remove_static_decl_with_type_rankValueFunc.P;
p << remove_static_decl_with_type_rankValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_rankValueFunc@
F << remove_static_inline_rankValueFunc.F;
T << remove_static_inline_rankValueFunc.T;
P << remove_static_inline_rankValueFunc.P;
p << remove_static_inline_rankValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: replaceFunc
@remove_static_def_brace_same_line_replaceFunc@
identifier F = { replaceFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_replaceFunc@
identifier F = { replaceFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_replaceFunc@
identifier F = { replaceFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_replaceFunc@
identifier F = { replaceFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_replaceFunc@
identifier F = { replaceFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_replaceFunc@
F << remove_static_def_brace_same_line_replaceFunc.F;
T << remove_static_def_brace_same_line_replaceFunc.T;
P << remove_static_def_brace_same_line_replaceFunc.P;
p << remove_static_def_brace_same_line_replaceFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_replaceFunc@
F << remove_static_def_brace_next_line_replaceFunc.F;
T << remove_static_def_brace_next_line_replaceFunc.T;
P << remove_static_def_brace_next_line_replaceFunc.P;
p << remove_static_def_brace_next_line_replaceFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_replaceFunc@
F << remove_static_def_no_type_replaceFunc.F;
P << remove_static_def_no_type_replaceFunc.P;
p << remove_static_def_no_type_replaceFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_replaceFunc@
F << remove_static_decl_with_type_replaceFunc.F;
T << remove_static_decl_with_type_replaceFunc.T;
P << remove_static_decl_with_type_replaceFunc.P;
p << remove_static_decl_with_type_replaceFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_replaceFunc@
F << remove_static_inline_replaceFunc.F;
T << remove_static_inline_replaceFunc.T;
P << remove_static_inline_replaceFunc.P;
p << remove_static_inline_replaceFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: resolveExprStep
@remove_static_def_brace_same_line_resolveExprStep@
identifier F = { resolveExprStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_resolveExprStep@
identifier F = { resolveExprStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_resolveExprStep@
identifier F = { resolveExprStep };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_resolveExprStep@
identifier F = { resolveExprStep };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_resolveExprStep@
identifier F = { resolveExprStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_resolveExprStep@
F << remove_static_def_brace_same_line_resolveExprStep.F;
T << remove_static_def_brace_same_line_resolveExprStep.T;
P << remove_static_def_brace_same_line_resolveExprStep.P;
p << remove_static_def_brace_same_line_resolveExprStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_resolveExprStep@
F << remove_static_def_brace_next_line_resolveExprStep.F;
T << remove_static_def_brace_next_line_resolveExprStep.T;
P << remove_static_def_brace_next_line_resolveExprStep.P;
p << remove_static_def_brace_next_line_resolveExprStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_resolveExprStep@
F << remove_static_def_no_type_resolveExprStep.F;
P << remove_static_def_no_type_resolveExprStep.P;
p << remove_static_def_no_type_resolveExprStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_resolveExprStep@
F << remove_static_decl_with_type_resolveExprStep.F;
T << remove_static_decl_with_type_resolveExprStep.T;
P << remove_static_decl_with_type_resolveExprStep.P;
p << remove_static_decl_with_type_resolveExprStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_resolveExprStep@
F << remove_static_inline_resolveExprStep.F;
T << remove_static_inline_resolveExprStep.T;
P << remove_static_inline_resolveExprStep.P;
p << remove_static_inline_resolveExprStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: resolveRemoveWindowsCb
@remove_static_def_brace_same_line_resolveRemoveWindowsCb@
identifier F = { resolveRemoveWindowsCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_resolveRemoveWindowsCb@
identifier F = { resolveRemoveWindowsCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_resolveRemoveWindowsCb@
identifier F = { resolveRemoveWindowsCb };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_resolveRemoveWindowsCb@
identifier F = { resolveRemoveWindowsCb };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_resolveRemoveWindowsCb@
identifier F = { resolveRemoveWindowsCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_resolveRemoveWindowsCb@
F << remove_static_def_brace_same_line_resolveRemoveWindowsCb.F;
T << remove_static_def_brace_same_line_resolveRemoveWindowsCb.T;
P << remove_static_def_brace_same_line_resolveRemoveWindowsCb.P;
p << remove_static_def_brace_same_line_resolveRemoveWindowsCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_resolveRemoveWindowsCb@
F << remove_static_def_brace_next_line_resolveRemoveWindowsCb.F;
T << remove_static_def_brace_next_line_resolveRemoveWindowsCb.T;
P << remove_static_def_brace_next_line_resolveRemoveWindowsCb.P;
p << remove_static_def_brace_next_line_resolveRemoveWindowsCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_resolveRemoveWindowsCb@
F << remove_static_def_no_type_resolveRemoveWindowsCb.F;
P << remove_static_def_no_type_resolveRemoveWindowsCb.P;
p << remove_static_def_no_type_resolveRemoveWindowsCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_resolveRemoveWindowsCb@
F << remove_static_decl_with_type_resolveRemoveWindowsCb.F;
T << remove_static_decl_with_type_resolveRemoveWindowsCb.T;
P << remove_static_decl_with_type_resolveRemoveWindowsCb.P;
p << remove_static_decl_with_type_resolveRemoveWindowsCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_resolveRemoveWindowsCb@
F << remove_static_inline_resolveRemoveWindowsCb.F;
T << remove_static_inline_resolveRemoveWindowsCb.T;
P << remove_static_inline_resolveRemoveWindowsCb.P;
p << remove_static_inline_resolveRemoveWindowsCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: resolveSelectStep
@remove_static_def_brace_same_line_resolveSelectStep@
identifier F = { resolveSelectStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_resolveSelectStep@
identifier F = { resolveSelectStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_resolveSelectStep@
identifier F = { resolveSelectStep };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_resolveSelectStep@
identifier F = { resolveSelectStep };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_resolveSelectStep@
identifier F = { resolveSelectStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_resolveSelectStep@
F << remove_static_def_brace_same_line_resolveSelectStep.F;
T << remove_static_def_brace_same_line_resolveSelectStep.T;
P << remove_static_def_brace_same_line_resolveSelectStep.P;
p << remove_static_def_brace_same_line_resolveSelectStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_resolveSelectStep@
F << remove_static_def_brace_next_line_resolveSelectStep.F;
T << remove_static_def_brace_next_line_resolveSelectStep.T;
P << remove_static_def_brace_next_line_resolveSelectStep.P;
p << remove_static_def_brace_next_line_resolveSelectStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_resolveSelectStep@
F << remove_static_def_no_type_resolveSelectStep.F;
P << remove_static_def_no_type_resolveSelectStep.P;
p << remove_static_def_no_type_resolveSelectStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_resolveSelectStep@
F << remove_static_decl_with_type_resolveSelectStep.F;
T << remove_static_decl_with_type_resolveSelectStep.T;
P << remove_static_decl_with_type_resolveSelectStep.P;
p << remove_static_decl_with_type_resolveSelectStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_resolveSelectStep@
F << remove_static_inline_resolveSelectStep.F;
T << remove_static_inline_resolveSelectStep.T;
P << remove_static_inline_resolveSelectStep.P;
p << remove_static_inline_resolveSelectStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: roundFunc
@remove_static_def_brace_same_line_roundFunc@
identifier F = { roundFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_roundFunc@
identifier F = { roundFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_roundFunc@
identifier F = { roundFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_roundFunc@
identifier F = { roundFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_roundFunc@
identifier F = { roundFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_roundFunc@
F << remove_static_def_brace_same_line_roundFunc.F;
T << remove_static_def_brace_same_line_roundFunc.T;
P << remove_static_def_brace_same_line_roundFunc.P;
p << remove_static_def_brace_same_line_roundFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_roundFunc@
F << remove_static_def_brace_next_line_roundFunc.F;
T << remove_static_def_brace_next_line_roundFunc.T;
P << remove_static_def_brace_next_line_roundFunc.P;
p << remove_static_def_brace_next_line_roundFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_roundFunc@
F << remove_static_def_no_type_roundFunc.F;
P << remove_static_def_no_type_roundFunc.P;
p << remove_static_def_no_type_roundFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_roundFunc@
F << remove_static_decl_with_type_roundFunc.F;
T << remove_static_decl_with_type_roundFunc.T;
P << remove_static_decl_with_type_roundFunc.P;
p << remove_static_decl_with_type_roundFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_roundFunc@
F << remove_static_inline_roundFunc.F;
T << remove_static_inline_roundFunc.T;
P << remove_static_inline_roundFunc.P;
p << remove_static_inline_roundFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: row_numberStepFunc
@remove_static_def_brace_same_line_row_numberStepFunc@
identifier F = { row_numberStepFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_row_numberStepFunc@
identifier F = { row_numberStepFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_row_numberStepFunc@
identifier F = { row_numberStepFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_row_numberStepFunc@
identifier F = { row_numberStepFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_row_numberStepFunc@
identifier F = { row_numberStepFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_row_numberStepFunc@
F << remove_static_def_brace_same_line_row_numberStepFunc.F;
T << remove_static_def_brace_same_line_row_numberStepFunc.T;
P << remove_static_def_brace_same_line_row_numberStepFunc.P;
p << remove_static_def_brace_same_line_row_numberStepFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_row_numberStepFunc@
F << remove_static_def_brace_next_line_row_numberStepFunc.F;
T << remove_static_def_brace_next_line_row_numberStepFunc.T;
P << remove_static_def_brace_next_line_row_numberStepFunc.P;
p << remove_static_def_brace_next_line_row_numberStepFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_row_numberStepFunc@
F << remove_static_def_no_type_row_numberStepFunc.F;
P << remove_static_def_no_type_row_numberStepFunc.P;
p << remove_static_def_no_type_row_numberStepFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_row_numberStepFunc@
F << remove_static_decl_with_type_row_numberStepFunc.F;
T << remove_static_decl_with_type_row_numberStepFunc.T;
P << remove_static_decl_with_type_row_numberStepFunc.P;
p << remove_static_decl_with_type_row_numberStepFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_row_numberStepFunc@
F << remove_static_inline_row_numberStepFunc.F;
T << remove_static_inline_row_numberStepFunc.T;
P << remove_static_inline_row_numberStepFunc.P;
p << remove_static_inline_row_numberStepFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: row_numberValueFunc
@remove_static_def_brace_same_line_row_numberValueFunc@
identifier F = { row_numberValueFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_row_numberValueFunc@
identifier F = { row_numberValueFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_row_numberValueFunc@
identifier F = { row_numberValueFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_row_numberValueFunc@
identifier F = { row_numberValueFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_row_numberValueFunc@
identifier F = { row_numberValueFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_row_numberValueFunc@
F << remove_static_def_brace_same_line_row_numberValueFunc.F;
T << remove_static_def_brace_same_line_row_numberValueFunc.T;
P << remove_static_def_brace_same_line_row_numberValueFunc.P;
p << remove_static_def_brace_same_line_row_numberValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_row_numberValueFunc@
F << remove_static_def_brace_next_line_row_numberValueFunc.F;
T << remove_static_def_brace_next_line_row_numberValueFunc.T;
P << remove_static_def_brace_next_line_row_numberValueFunc.P;
p << remove_static_def_brace_next_line_row_numberValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_row_numberValueFunc@
F << remove_static_def_no_type_row_numberValueFunc.F;
P << remove_static_def_no_type_row_numberValueFunc.P;
p << remove_static_def_no_type_row_numberValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_row_numberValueFunc@
F << remove_static_decl_with_type_row_numberValueFunc.F;
T << remove_static_decl_with_type_row_numberValueFunc.T;
P << remove_static_decl_with_type_row_numberValueFunc.P;
p << remove_static_decl_with_type_row_numberValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_row_numberValueFunc@
F << remove_static_inline_row_numberValueFunc.F;
T << remove_static_inline_row_numberValueFunc.T;
P << remove_static_inline_row_numberValueFunc.P;
p << remove_static_inline_row_numberValueFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: selectAddSubqueryTypeInfo
@remove_static_def_brace_same_line_selectAddSubqueryTypeInfo@
identifier F = { selectAddSubqueryTypeInfo };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_selectAddSubqueryTypeInfo@
identifier F = { selectAddSubqueryTypeInfo };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_selectAddSubqueryTypeInfo@
identifier F = { selectAddSubqueryTypeInfo };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_selectAddSubqueryTypeInfo@
identifier F = { selectAddSubqueryTypeInfo };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_selectAddSubqueryTypeInfo@
identifier F = { selectAddSubqueryTypeInfo };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_selectAddSubqueryTypeInfo@
F << remove_static_def_brace_same_line_selectAddSubqueryTypeInfo.F;
T << remove_static_def_brace_same_line_selectAddSubqueryTypeInfo.T;
P << remove_static_def_brace_same_line_selectAddSubqueryTypeInfo.P;
p << remove_static_def_brace_same_line_selectAddSubqueryTypeInfo.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_selectAddSubqueryTypeInfo@
F << remove_static_def_brace_next_line_selectAddSubqueryTypeInfo.F;
T << remove_static_def_brace_next_line_selectAddSubqueryTypeInfo.T;
P << remove_static_def_brace_next_line_selectAddSubqueryTypeInfo.P;
p << remove_static_def_brace_next_line_selectAddSubqueryTypeInfo.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_selectAddSubqueryTypeInfo@
F << remove_static_def_no_type_selectAddSubqueryTypeInfo.F;
P << remove_static_def_no_type_selectAddSubqueryTypeInfo.P;
p << remove_static_def_no_type_selectAddSubqueryTypeInfo.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_selectAddSubqueryTypeInfo@
F << remove_static_decl_with_type_selectAddSubqueryTypeInfo.F;
T << remove_static_decl_with_type_selectAddSubqueryTypeInfo.T;
P << remove_static_decl_with_type_selectAddSubqueryTypeInfo.P;
p << remove_static_decl_with_type_selectAddSubqueryTypeInfo.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_selectAddSubqueryTypeInfo@
F << remove_static_inline_selectAddSubqueryTypeInfo.F;
T << remove_static_inline_selectAddSubqueryTypeInfo.T;
P << remove_static_inline_selectAddSubqueryTypeInfo.P;
p << remove_static_inline_selectAddSubqueryTypeInfo.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: selectCheckOnClausesExpr
@remove_static_def_brace_same_line_selectCheckOnClausesExpr@
identifier F = { selectCheckOnClausesExpr };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_selectCheckOnClausesExpr@
identifier F = { selectCheckOnClausesExpr };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_selectCheckOnClausesExpr@
identifier F = { selectCheckOnClausesExpr };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_selectCheckOnClausesExpr@
identifier F = { selectCheckOnClausesExpr };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_selectCheckOnClausesExpr@
identifier F = { selectCheckOnClausesExpr };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_selectCheckOnClausesExpr@
F << remove_static_def_brace_same_line_selectCheckOnClausesExpr.F;
T << remove_static_def_brace_same_line_selectCheckOnClausesExpr.T;
P << remove_static_def_brace_same_line_selectCheckOnClausesExpr.P;
p << remove_static_def_brace_same_line_selectCheckOnClausesExpr.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_selectCheckOnClausesExpr@
F << remove_static_def_brace_next_line_selectCheckOnClausesExpr.F;
T << remove_static_def_brace_next_line_selectCheckOnClausesExpr.T;
P << remove_static_def_brace_next_line_selectCheckOnClausesExpr.P;
p << remove_static_def_brace_next_line_selectCheckOnClausesExpr.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_selectCheckOnClausesExpr@
F << remove_static_def_no_type_selectCheckOnClausesExpr.F;
P << remove_static_def_no_type_selectCheckOnClausesExpr.P;
p << remove_static_def_no_type_selectCheckOnClausesExpr.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_selectCheckOnClausesExpr@
F << remove_static_decl_with_type_selectCheckOnClausesExpr.F;
T << remove_static_decl_with_type_selectCheckOnClausesExpr.T;
P << remove_static_decl_with_type_selectCheckOnClausesExpr.P;
p << remove_static_decl_with_type_selectCheckOnClausesExpr.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_selectCheckOnClausesExpr@
F << remove_static_inline_selectCheckOnClausesExpr.F;
T << remove_static_inline_selectCheckOnClausesExpr.T;
P << remove_static_inline_selectCheckOnClausesExpr.P;
p << remove_static_inline_selectCheckOnClausesExpr.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: selectExpander
@remove_static_def_brace_same_line_selectExpander@
identifier F = { selectExpander };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_selectExpander@
identifier F = { selectExpander };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_selectExpander@
identifier F = { selectExpander };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_selectExpander@
identifier F = { selectExpander };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_selectExpander@
identifier F = { selectExpander };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_selectExpander@
F << remove_static_def_brace_same_line_selectExpander.F;
T << remove_static_def_brace_same_line_selectExpander.T;
P << remove_static_def_brace_same_line_selectExpander.P;
p << remove_static_def_brace_same_line_selectExpander.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_selectExpander@
F << remove_static_def_brace_next_line_selectExpander.F;
T << remove_static_def_brace_next_line_selectExpander.T;
P << remove_static_def_brace_next_line_selectExpander.P;
p << remove_static_def_brace_next_line_selectExpander.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_selectExpander@
F << remove_static_def_no_type_selectExpander.F;
P << remove_static_def_no_type_selectExpander.P;
p << remove_static_def_no_type_selectExpander.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_selectExpander@
F << remove_static_decl_with_type_selectExpander.F;
T << remove_static_decl_with_type_selectExpander.T;
P << remove_static_decl_with_type_selectExpander.P;
p << remove_static_decl_with_type_selectExpander.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_selectExpander@
F << remove_static_inline_selectExpander.F;
T << remove_static_inline_selectExpander.T;
P << remove_static_inline_selectExpander.P;
p << remove_static_inline_selectExpander.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: selectWindowRewriteExprCb
@remove_static_def_brace_same_line_selectWindowRewriteExprCb@
identifier F = { selectWindowRewriteExprCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_selectWindowRewriteExprCb@
identifier F = { selectWindowRewriteExprCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_selectWindowRewriteExprCb@
identifier F = { selectWindowRewriteExprCb };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_selectWindowRewriteExprCb@
identifier F = { selectWindowRewriteExprCb };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_selectWindowRewriteExprCb@
identifier F = { selectWindowRewriteExprCb };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_selectWindowRewriteExprCb@
F << remove_static_def_brace_same_line_selectWindowRewriteExprCb.F;
T << remove_static_def_brace_same_line_selectWindowRewriteExprCb.T;
P << remove_static_def_brace_same_line_selectWindowRewriteExprCb.P;
p << remove_static_def_brace_same_line_selectWindowRewriteExprCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_selectWindowRewriteExprCb@
F << remove_static_def_brace_next_line_selectWindowRewriteExprCb.F;
T << remove_static_def_brace_next_line_selectWindowRewriteExprCb.T;
P << remove_static_def_brace_next_line_selectWindowRewriteExprCb.P;
p << remove_static_def_brace_next_line_selectWindowRewriteExprCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_selectWindowRewriteExprCb@
F << remove_static_def_no_type_selectWindowRewriteExprCb.F;
P << remove_static_def_no_type_selectWindowRewriteExprCb.P;
p << remove_static_def_no_type_selectWindowRewriteExprCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_selectWindowRewriteExprCb@
F << remove_static_decl_with_type_selectWindowRewriteExprCb.F;
T << remove_static_decl_with_type_selectWindowRewriteExprCb.T;
P << remove_static_decl_with_type_selectWindowRewriteExprCb.P;
p << remove_static_decl_with_type_selectWindowRewriteExprCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_selectWindowRewriteExprCb@
F << remove_static_inline_selectWindowRewriteExprCb.F;
T << remove_static_inline_selectWindowRewriteExprCb.T;
P << remove_static_inline_selectWindowRewriteExprCb.P;
p << remove_static_inline_selectWindowRewriteExprCb.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: shellLog
@remove_static_def_brace_same_line_shellLog@
identifier F = { shellLog };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_shellLog@
identifier F = { shellLog };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_shellLog@
identifier F = { shellLog };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_shellLog@
identifier F = { shellLog };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_shellLog@
identifier F = { shellLog };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_shellLog@
F << remove_static_def_brace_same_line_shellLog.F;
T << remove_static_def_brace_same_line_shellLog.T;
P << remove_static_def_brace_same_line_shellLog.P;
p << remove_static_def_brace_same_line_shellLog.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_shellLog@
F << remove_static_def_brace_next_line_shellLog.F;
T << remove_static_def_brace_next_line_shellLog.T;
P << remove_static_def_brace_next_line_shellLog.P;
p << remove_static_def_brace_next_line_shellLog.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_shellLog@
F << remove_static_def_no_type_shellLog.F;
P << remove_static_def_no_type_shellLog.P;
p << remove_static_def_no_type_shellLog.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_shellLog@
F << remove_static_decl_with_type_shellLog.F;
T << remove_static_decl_with_type_shellLog.T;
P << remove_static_decl_with_type_shellLog.P;
p << remove_static_decl_with_type_shellLog.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_shellLog@
F << remove_static_inline_shellLog.F;
T << remove_static_inline_shellLog.T;
P << remove_static_inline_shellLog.P;
p << remove_static_inline_shellLog.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: signFunc
@remove_static_def_brace_same_line_signFunc@
identifier F = { signFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_signFunc@
identifier F = { signFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_signFunc@
identifier F = { signFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_signFunc@
identifier F = { signFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_signFunc@
identifier F = { signFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_signFunc@
F << remove_static_def_brace_same_line_signFunc.F;
T << remove_static_def_brace_same_line_signFunc.T;
P << remove_static_def_brace_same_line_signFunc.P;
p << remove_static_def_brace_same_line_signFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_signFunc@
F << remove_static_def_brace_next_line_signFunc.F;
T << remove_static_def_brace_next_line_signFunc.T;
P << remove_static_def_brace_next_line_signFunc.P;
p << remove_static_def_brace_next_line_signFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_signFunc@
F << remove_static_def_no_type_signFunc.F;
P << remove_static_def_no_type_signFunc.P;
p << remove_static_def_no_type_signFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_signFunc@
F << remove_static_decl_with_type_signFunc.F;
T << remove_static_decl_with_type_signFunc.T;
P << remove_static_decl_with_type_signFunc.P;
p << remove_static_decl_with_type_signFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_signFunc@
F << remove_static_inline_signFunc.F;
T << remove_static_inline_signFunc.T;
P << remove_static_inline_signFunc.P;
p << remove_static_inline_signFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sourceidFunc
@remove_static_def_brace_same_line_sourceidFunc@
identifier F = { sourceidFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sourceidFunc@
identifier F = { sourceidFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sourceidFunc@
identifier F = { sourceidFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sourceidFunc@
identifier F = { sourceidFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sourceidFunc@
identifier F = { sourceidFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sourceidFunc@
F << remove_static_def_brace_same_line_sourceidFunc.F;
T << remove_static_def_brace_same_line_sourceidFunc.T;
P << remove_static_def_brace_same_line_sourceidFunc.P;
p << remove_static_def_brace_same_line_sourceidFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sourceidFunc@
F << remove_static_def_brace_next_line_sourceidFunc.F;
T << remove_static_def_brace_next_line_sourceidFunc.T;
P << remove_static_def_brace_next_line_sourceidFunc.P;
p << remove_static_def_brace_next_line_sourceidFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sourceidFunc@
F << remove_static_def_no_type_sourceidFunc.F;
P << remove_static_def_no_type_sourceidFunc.P;
p << remove_static_def_no_type_sourceidFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sourceidFunc@
F << remove_static_decl_with_type_sourceidFunc.F;
T << remove_static_decl_with_type_sourceidFunc.T;
P << remove_static_decl_with_type_sourceidFunc.P;
p << remove_static_decl_with_type_sourceidFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sourceidFunc@
F << remove_static_inline_sourceidFunc.F;
T << remove_static_inline_sourceidFunc.T;
P << remove_static_inline_sourceidFunc.P;
p << remove_static_inline_sourceidFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3DbFree
@remove_static_def_brace_same_line_sqlite3DbFree@
identifier F = { sqlite3DbFree };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3DbFree@
identifier F = { sqlite3DbFree };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3DbFree@
identifier F = { sqlite3DbFree };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3DbFree@
identifier F = { sqlite3DbFree };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3DbFree@
identifier F = { sqlite3DbFree };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3DbFree@
F << remove_static_def_brace_same_line_sqlite3DbFree.F;
T << remove_static_def_brace_same_line_sqlite3DbFree.T;
P << remove_static_def_brace_same_line_sqlite3DbFree.P;
p << remove_static_def_brace_same_line_sqlite3DbFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3DbFree@
F << remove_static_def_brace_next_line_sqlite3DbFree.F;
T << remove_static_def_brace_next_line_sqlite3DbFree.T;
P << remove_static_def_brace_next_line_sqlite3DbFree.P;
p << remove_static_def_brace_next_line_sqlite3DbFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3DbFree@
F << remove_static_def_no_type_sqlite3DbFree.F;
P << remove_static_def_no_type_sqlite3DbFree.P;
p << remove_static_def_no_type_sqlite3DbFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3DbFree@
F << remove_static_decl_with_type_sqlite3DbFree.F;
T << remove_static_decl_with_type_sqlite3DbFree.T;
P << remove_static_decl_with_type_sqlite3DbFree.P;
p << remove_static_decl_with_type_sqlite3DbFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3DbFree@
F << remove_static_inline_sqlite3DbFree.F;
T << remove_static_inline_sqlite3DbFree.T;
P << remove_static_inline_sqlite3DbFree.P;
p << remove_static_inline_sqlite3DbFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3DbpageRegister
@remove_static_def_brace_same_line_sqlite3DbpageRegister@
identifier F = { sqlite3DbpageRegister };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3DbpageRegister@
identifier F = { sqlite3DbpageRegister };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3DbpageRegister@
identifier F = { sqlite3DbpageRegister };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3DbpageRegister@
identifier F = { sqlite3DbpageRegister };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3DbpageRegister@
identifier F = { sqlite3DbpageRegister };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3DbpageRegister@
F << remove_static_def_brace_same_line_sqlite3DbpageRegister.F;
T << remove_static_def_brace_same_line_sqlite3DbpageRegister.T;
P << remove_static_def_brace_same_line_sqlite3DbpageRegister.P;
p << remove_static_def_brace_same_line_sqlite3DbpageRegister.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3DbpageRegister@
F << remove_static_def_brace_next_line_sqlite3DbpageRegister.F;
T << remove_static_def_brace_next_line_sqlite3DbpageRegister.T;
P << remove_static_def_brace_next_line_sqlite3DbpageRegister.P;
p << remove_static_def_brace_next_line_sqlite3DbpageRegister.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3DbpageRegister@
F << remove_static_def_no_type_sqlite3DbpageRegister.F;
P << remove_static_def_no_type_sqlite3DbpageRegister.P;
p << remove_static_def_no_type_sqlite3DbpageRegister.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3DbpageRegister@
F << remove_static_decl_with_type_sqlite3DbpageRegister.F;
T << remove_static_decl_with_type_sqlite3DbpageRegister.T;
P << remove_static_decl_with_type_sqlite3DbpageRegister.P;
p << remove_static_decl_with_type_sqlite3DbpageRegister.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3DbpageRegister@
F << remove_static_inline_sqlite3DbpageRegister.F;
T << remove_static_inline_sqlite3DbpageRegister.T;
P << remove_static_inline_sqlite3DbpageRegister.P;
p << remove_static_inline_sqlite3DbpageRegister.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3DbstatRegister
@remove_static_def_brace_same_line_sqlite3DbstatRegister@
identifier F = { sqlite3DbstatRegister };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3DbstatRegister@
identifier F = { sqlite3DbstatRegister };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3DbstatRegister@
identifier F = { sqlite3DbstatRegister };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3DbstatRegister@
identifier F = { sqlite3DbstatRegister };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3DbstatRegister@
identifier F = { sqlite3DbstatRegister };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3DbstatRegister@
F << remove_static_def_brace_same_line_sqlite3DbstatRegister.F;
T << remove_static_def_brace_same_line_sqlite3DbstatRegister.T;
P << remove_static_def_brace_same_line_sqlite3DbstatRegister.P;
p << remove_static_def_brace_same_line_sqlite3DbstatRegister.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3DbstatRegister@
F << remove_static_def_brace_next_line_sqlite3DbstatRegister.F;
T << remove_static_def_brace_next_line_sqlite3DbstatRegister.T;
P << remove_static_def_brace_next_line_sqlite3DbstatRegister.P;
p << remove_static_def_brace_next_line_sqlite3DbstatRegister.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3DbstatRegister@
F << remove_static_def_no_type_sqlite3DbstatRegister.F;
P << remove_static_def_no_type_sqlite3DbstatRegister.P;
p << remove_static_def_no_type_sqlite3DbstatRegister.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3DbstatRegister@
F << remove_static_decl_with_type_sqlite3DbstatRegister.F;
T << remove_static_decl_with_type_sqlite3DbstatRegister.T;
P << remove_static_decl_with_type_sqlite3DbstatRegister.P;
p << remove_static_decl_with_type_sqlite3DbstatRegister.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3DbstatRegister@
F << remove_static_inline_sqlite3DbstatRegister.F;
T << remove_static_inline_sqlite3DbstatRegister.T;
P << remove_static_inline_sqlite3DbstatRegister.P;
p << remove_static_inline_sqlite3DbstatRegister.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3ExprDeleteGeneric
@remove_static_def_brace_same_line_sqlite3ExprDeleteGeneric@
identifier F = { sqlite3ExprDeleteGeneric };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3ExprDeleteGeneric@
identifier F = { sqlite3ExprDeleteGeneric };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3ExprDeleteGeneric@
identifier F = { sqlite3ExprDeleteGeneric };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3ExprDeleteGeneric@
identifier F = { sqlite3ExprDeleteGeneric };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3ExprDeleteGeneric@
identifier F = { sqlite3ExprDeleteGeneric };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3ExprDeleteGeneric@
F << remove_static_def_brace_same_line_sqlite3ExprDeleteGeneric.F;
T << remove_static_def_brace_same_line_sqlite3ExprDeleteGeneric.T;
P << remove_static_def_brace_same_line_sqlite3ExprDeleteGeneric.P;
p << remove_static_def_brace_same_line_sqlite3ExprDeleteGeneric.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3ExprDeleteGeneric@
F << remove_static_def_brace_next_line_sqlite3ExprDeleteGeneric.F;
T << remove_static_def_brace_next_line_sqlite3ExprDeleteGeneric.T;
P << remove_static_def_brace_next_line_sqlite3ExprDeleteGeneric.P;
p << remove_static_def_brace_next_line_sqlite3ExprDeleteGeneric.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3ExprDeleteGeneric@
F << remove_static_def_no_type_sqlite3ExprDeleteGeneric.F;
P << remove_static_def_no_type_sqlite3ExprDeleteGeneric.P;
p << remove_static_def_no_type_sqlite3ExprDeleteGeneric.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3ExprDeleteGeneric@
F << remove_static_decl_with_type_sqlite3ExprDeleteGeneric.F;
T << remove_static_decl_with_type_sqlite3ExprDeleteGeneric.T;
P << remove_static_decl_with_type_sqlite3ExprDeleteGeneric.P;
p << remove_static_decl_with_type_sqlite3ExprDeleteGeneric.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3ExprDeleteGeneric@
F << remove_static_inline_sqlite3ExprDeleteGeneric.F;
T << remove_static_inline_sqlite3ExprDeleteGeneric.T;
P << remove_static_inline_sqlite3ExprDeleteGeneric.P;
p << remove_static_inline_sqlite3ExprDeleteGeneric.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3ExprWalkNoop
@remove_static_def_brace_same_line_sqlite3ExprWalkNoop@
identifier F = { sqlite3ExprWalkNoop };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3ExprWalkNoop@
identifier F = { sqlite3ExprWalkNoop };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3ExprWalkNoop@
identifier F = { sqlite3ExprWalkNoop };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3ExprWalkNoop@
identifier F = { sqlite3ExprWalkNoop };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3ExprWalkNoop@
identifier F = { sqlite3ExprWalkNoop };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3ExprWalkNoop@
F << remove_static_def_brace_same_line_sqlite3ExprWalkNoop.F;
T << remove_static_def_brace_same_line_sqlite3ExprWalkNoop.T;
P << remove_static_def_brace_same_line_sqlite3ExprWalkNoop.P;
p << remove_static_def_brace_same_line_sqlite3ExprWalkNoop.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3ExprWalkNoop@
F << remove_static_def_brace_next_line_sqlite3ExprWalkNoop.F;
T << remove_static_def_brace_next_line_sqlite3ExprWalkNoop.T;
P << remove_static_def_brace_next_line_sqlite3ExprWalkNoop.P;
p << remove_static_def_brace_next_line_sqlite3ExprWalkNoop.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3ExprWalkNoop@
F << remove_static_def_no_type_sqlite3ExprWalkNoop.F;
P << remove_static_def_no_type_sqlite3ExprWalkNoop.P;
p << remove_static_def_no_type_sqlite3ExprWalkNoop.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3ExprWalkNoop@
F << remove_static_decl_with_type_sqlite3ExprWalkNoop.F;
T << remove_static_decl_with_type_sqlite3ExprWalkNoop.T;
P << remove_static_decl_with_type_sqlite3ExprWalkNoop.P;
p << remove_static_decl_with_type_sqlite3ExprWalkNoop.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3ExprWalkNoop@
F << remove_static_inline_sqlite3ExprWalkNoop.F;
T << remove_static_inline_sqlite3ExprWalkNoop.T;
P << remove_static_inline_sqlite3ExprWalkNoop.P;
p << remove_static_inline_sqlite3ExprWalkNoop.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3Fts3Init
@remove_static_def_brace_same_line_sqlite3Fts3Init@
identifier F = { sqlite3Fts3Init };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3Fts3Init@
identifier F = { sqlite3Fts3Init };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3Fts3Init@
identifier F = { sqlite3Fts3Init };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3Fts3Init@
identifier F = { sqlite3Fts3Init };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3Fts3Init@
identifier F = { sqlite3Fts3Init };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3Fts3Init@
F << remove_static_def_brace_same_line_sqlite3Fts3Init.F;
T << remove_static_def_brace_same_line_sqlite3Fts3Init.T;
P << remove_static_def_brace_same_line_sqlite3Fts3Init.P;
p << remove_static_def_brace_same_line_sqlite3Fts3Init.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3Fts3Init@
F << remove_static_def_brace_next_line_sqlite3Fts3Init.F;
T << remove_static_def_brace_next_line_sqlite3Fts3Init.T;
P << remove_static_def_brace_next_line_sqlite3Fts3Init.P;
p << remove_static_def_brace_next_line_sqlite3Fts3Init.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3Fts3Init@
F << remove_static_def_no_type_sqlite3Fts3Init.F;
P << remove_static_def_no_type_sqlite3Fts3Init.P;
p << remove_static_def_no_type_sqlite3Fts3Init.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3Fts3Init@
F << remove_static_decl_with_type_sqlite3Fts3Init.F;
T << remove_static_decl_with_type_sqlite3Fts3Init.T;
P << remove_static_decl_with_type_sqlite3Fts3Init.P;
p << remove_static_decl_with_type_sqlite3Fts3Init.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3Fts3Init@
F << remove_static_inline_sqlite3Fts3Init.F;
T << remove_static_inline_sqlite3Fts3Init.T;
P << remove_static_inline_sqlite3Fts3Init.P;
p << remove_static_inline_sqlite3Fts3Init.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3InitCallback
@remove_static_def_brace_same_line_sqlite3InitCallback@
identifier F = { sqlite3InitCallback };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3InitCallback@
identifier F = { sqlite3InitCallback };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3InitCallback@
identifier F = { sqlite3InitCallback };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3InitCallback@
identifier F = { sqlite3InitCallback };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3InitCallback@
identifier F = { sqlite3InitCallback };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3InitCallback@
F << remove_static_def_brace_same_line_sqlite3InitCallback.F;
T << remove_static_def_brace_same_line_sqlite3InitCallback.T;
P << remove_static_def_brace_same_line_sqlite3InitCallback.P;
p << remove_static_def_brace_same_line_sqlite3InitCallback.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3InitCallback@
F << remove_static_def_brace_next_line_sqlite3InitCallback.F;
T << remove_static_def_brace_next_line_sqlite3InitCallback.T;
P << remove_static_def_brace_next_line_sqlite3InitCallback.P;
p << remove_static_def_brace_next_line_sqlite3InitCallback.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3InitCallback@
F << remove_static_def_no_type_sqlite3InitCallback.F;
P << remove_static_def_no_type_sqlite3InitCallback.P;
p << remove_static_def_no_type_sqlite3InitCallback.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3InitCallback@
F << remove_static_decl_with_type_sqlite3InitCallback.F;
T << remove_static_decl_with_type_sqlite3InitCallback.T;
P << remove_static_decl_with_type_sqlite3InitCallback.P;
p << remove_static_decl_with_type_sqlite3InitCallback.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3InitCallback@
F << remove_static_inline_sqlite3InitCallback.F;
T << remove_static_inline_sqlite3InitCallback.T;
P << remove_static_inline_sqlite3InitCallback.P;
p << remove_static_inline_sqlite3InitCallback.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3JsonTableFunctions
@remove_static_def_brace_same_line_sqlite3JsonTableFunctions@
identifier F = { sqlite3JsonTableFunctions };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3JsonTableFunctions@
identifier F = { sqlite3JsonTableFunctions };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3JsonTableFunctions@
identifier F = { sqlite3JsonTableFunctions };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3JsonTableFunctions@
identifier F = { sqlite3JsonTableFunctions };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3JsonTableFunctions@
identifier F = { sqlite3JsonTableFunctions };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3JsonTableFunctions@
F << remove_static_def_brace_same_line_sqlite3JsonTableFunctions.F;
T << remove_static_def_brace_same_line_sqlite3JsonTableFunctions.T;
P << remove_static_def_brace_same_line_sqlite3JsonTableFunctions.P;
p << remove_static_def_brace_same_line_sqlite3JsonTableFunctions.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3JsonTableFunctions@
F << remove_static_def_brace_next_line_sqlite3JsonTableFunctions.F;
T << remove_static_def_brace_next_line_sqlite3JsonTableFunctions.T;
P << remove_static_def_brace_next_line_sqlite3JsonTableFunctions.P;
p << remove_static_def_brace_next_line_sqlite3JsonTableFunctions.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3JsonTableFunctions@
F << remove_static_def_no_type_sqlite3JsonTableFunctions.F;
P << remove_static_def_no_type_sqlite3JsonTableFunctions.P;
p << remove_static_def_no_type_sqlite3JsonTableFunctions.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3JsonTableFunctions@
F << remove_static_decl_with_type_sqlite3JsonTableFunctions.F;
T << remove_static_decl_with_type_sqlite3JsonTableFunctions.T;
P << remove_static_decl_with_type_sqlite3JsonTableFunctions.P;
p << remove_static_decl_with_type_sqlite3JsonTableFunctions.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3JsonTableFunctions@
F << remove_static_inline_sqlite3JsonTableFunctions.F;
T << remove_static_inline_sqlite3JsonTableFunctions.T;
P << remove_static_inline_sqlite3JsonTableFunctions.P;
p << remove_static_inline_sqlite3JsonTableFunctions.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3MemFree
@remove_static_def_brace_same_line_sqlite3MemFree@
identifier F = { sqlite3MemFree };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3MemFree@
identifier F = { sqlite3MemFree };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3MemFree@
identifier F = { sqlite3MemFree };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3MemFree@
identifier F = { sqlite3MemFree };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3MemFree@
identifier F = { sqlite3MemFree };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3MemFree@
F << remove_static_def_brace_same_line_sqlite3MemFree.F;
T << remove_static_def_brace_same_line_sqlite3MemFree.T;
P << remove_static_def_brace_same_line_sqlite3MemFree.P;
p << remove_static_def_brace_same_line_sqlite3MemFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3MemFree@
F << remove_static_def_brace_next_line_sqlite3MemFree.F;
T << remove_static_def_brace_next_line_sqlite3MemFree.T;
P << remove_static_def_brace_next_line_sqlite3MemFree.P;
p << remove_static_def_brace_next_line_sqlite3MemFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3MemFree@
F << remove_static_def_no_type_sqlite3MemFree.F;
P << remove_static_def_no_type_sqlite3MemFree.P;
p << remove_static_def_no_type_sqlite3MemFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3MemFree@
F << remove_static_decl_with_type_sqlite3MemFree.F;
T << remove_static_decl_with_type_sqlite3MemFree.T;
P << remove_static_decl_with_type_sqlite3MemFree.P;
p << remove_static_decl_with_type_sqlite3MemFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3MemFree@
F << remove_static_inline_sqlite3MemFree.F;
T << remove_static_inline_sqlite3MemFree.T;
P << remove_static_inline_sqlite3MemFree.P;
p << remove_static_inline_sqlite3MemFree.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3MemInit
@remove_static_def_brace_same_line_sqlite3MemInit@
identifier F = { sqlite3MemInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3MemInit@
identifier F = { sqlite3MemInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3MemInit@
identifier F = { sqlite3MemInit };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3MemInit@
identifier F = { sqlite3MemInit };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3MemInit@
identifier F = { sqlite3MemInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3MemInit@
F << remove_static_def_brace_same_line_sqlite3MemInit.F;
T << remove_static_def_brace_same_line_sqlite3MemInit.T;
P << remove_static_def_brace_same_line_sqlite3MemInit.P;
p << remove_static_def_brace_same_line_sqlite3MemInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3MemInit@
F << remove_static_def_brace_next_line_sqlite3MemInit.F;
T << remove_static_def_brace_next_line_sqlite3MemInit.T;
P << remove_static_def_brace_next_line_sqlite3MemInit.P;
p << remove_static_def_brace_next_line_sqlite3MemInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3MemInit@
F << remove_static_def_no_type_sqlite3MemInit.F;
P << remove_static_def_no_type_sqlite3MemInit.P;
p << remove_static_def_no_type_sqlite3MemInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3MemInit@
F << remove_static_decl_with_type_sqlite3MemInit.F;
T << remove_static_decl_with_type_sqlite3MemInit.T;
P << remove_static_decl_with_type_sqlite3MemInit.P;
p << remove_static_decl_with_type_sqlite3MemInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3MemInit@
F << remove_static_inline_sqlite3MemInit.F;
T << remove_static_inline_sqlite3MemInit.T;
P << remove_static_inline_sqlite3MemInit.P;
p << remove_static_inline_sqlite3MemInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3MemMalloc
@remove_static_def_brace_same_line_sqlite3MemMalloc@
identifier F = { sqlite3MemMalloc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3MemMalloc@
identifier F = { sqlite3MemMalloc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3MemMalloc@
identifier F = { sqlite3MemMalloc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3MemMalloc@
identifier F = { sqlite3MemMalloc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3MemMalloc@
identifier F = { sqlite3MemMalloc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3MemMalloc@
F << remove_static_def_brace_same_line_sqlite3MemMalloc.F;
T << remove_static_def_brace_same_line_sqlite3MemMalloc.T;
P << remove_static_def_brace_same_line_sqlite3MemMalloc.P;
p << remove_static_def_brace_same_line_sqlite3MemMalloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3MemMalloc@
F << remove_static_def_brace_next_line_sqlite3MemMalloc.F;
T << remove_static_def_brace_next_line_sqlite3MemMalloc.T;
P << remove_static_def_brace_next_line_sqlite3MemMalloc.P;
p << remove_static_def_brace_next_line_sqlite3MemMalloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3MemMalloc@
F << remove_static_def_no_type_sqlite3MemMalloc.F;
P << remove_static_def_no_type_sqlite3MemMalloc.P;
p << remove_static_def_no_type_sqlite3MemMalloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3MemMalloc@
F << remove_static_decl_with_type_sqlite3MemMalloc.F;
T << remove_static_decl_with_type_sqlite3MemMalloc.T;
P << remove_static_decl_with_type_sqlite3MemMalloc.P;
p << remove_static_decl_with_type_sqlite3MemMalloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3MemMalloc@
F << remove_static_inline_sqlite3MemMalloc.F;
T << remove_static_inline_sqlite3MemMalloc.T;
P << remove_static_inline_sqlite3MemMalloc.P;
p << remove_static_inline_sqlite3MemMalloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3MemRealloc
@remove_static_def_brace_same_line_sqlite3MemRealloc@
identifier F = { sqlite3MemRealloc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3MemRealloc@
identifier F = { sqlite3MemRealloc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3MemRealloc@
identifier F = { sqlite3MemRealloc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3MemRealloc@
identifier F = { sqlite3MemRealloc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3MemRealloc@
identifier F = { sqlite3MemRealloc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3MemRealloc@
F << remove_static_def_brace_same_line_sqlite3MemRealloc.F;
T << remove_static_def_brace_same_line_sqlite3MemRealloc.T;
P << remove_static_def_brace_same_line_sqlite3MemRealloc.P;
p << remove_static_def_brace_same_line_sqlite3MemRealloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3MemRealloc@
F << remove_static_def_brace_next_line_sqlite3MemRealloc.F;
T << remove_static_def_brace_next_line_sqlite3MemRealloc.T;
P << remove_static_def_brace_next_line_sqlite3MemRealloc.P;
p << remove_static_def_brace_next_line_sqlite3MemRealloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3MemRealloc@
F << remove_static_def_no_type_sqlite3MemRealloc.F;
P << remove_static_def_no_type_sqlite3MemRealloc.P;
p << remove_static_def_no_type_sqlite3MemRealloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3MemRealloc@
F << remove_static_decl_with_type_sqlite3MemRealloc.F;
T << remove_static_decl_with_type_sqlite3MemRealloc.T;
P << remove_static_decl_with_type_sqlite3MemRealloc.P;
p << remove_static_decl_with_type_sqlite3MemRealloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3MemRealloc@
F << remove_static_inline_sqlite3MemRealloc.F;
T << remove_static_inline_sqlite3MemRealloc.T;
P << remove_static_inline_sqlite3MemRealloc.P;
p << remove_static_inline_sqlite3MemRealloc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3MemRoundup
@remove_static_def_brace_same_line_sqlite3MemRoundup@
identifier F = { sqlite3MemRoundup };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3MemRoundup@
identifier F = { sqlite3MemRoundup };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3MemRoundup@
identifier F = { sqlite3MemRoundup };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3MemRoundup@
identifier F = { sqlite3MemRoundup };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3MemRoundup@
identifier F = { sqlite3MemRoundup };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3MemRoundup@
F << remove_static_def_brace_same_line_sqlite3MemRoundup.F;
T << remove_static_def_brace_same_line_sqlite3MemRoundup.T;
P << remove_static_def_brace_same_line_sqlite3MemRoundup.P;
p << remove_static_def_brace_same_line_sqlite3MemRoundup.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3MemRoundup@
F << remove_static_def_brace_next_line_sqlite3MemRoundup.F;
T << remove_static_def_brace_next_line_sqlite3MemRoundup.T;
P << remove_static_def_brace_next_line_sqlite3MemRoundup.P;
p << remove_static_def_brace_next_line_sqlite3MemRoundup.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3MemRoundup@
F << remove_static_def_no_type_sqlite3MemRoundup.F;
P << remove_static_def_no_type_sqlite3MemRoundup.P;
p << remove_static_def_no_type_sqlite3MemRoundup.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3MemRoundup@
F << remove_static_decl_with_type_sqlite3MemRoundup.F;
T << remove_static_decl_with_type_sqlite3MemRoundup.T;
P << remove_static_decl_with_type_sqlite3MemRoundup.P;
p << remove_static_decl_with_type_sqlite3MemRoundup.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3MemRoundup@
F << remove_static_inline_sqlite3MemRoundup.F;
T << remove_static_inline_sqlite3MemRoundup.T;
P << remove_static_inline_sqlite3MemRoundup.P;
p << remove_static_inline_sqlite3MemRoundup.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3MemShutdown
@remove_static_def_brace_same_line_sqlite3MemShutdown@
identifier F = { sqlite3MemShutdown };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3MemShutdown@
identifier F = { sqlite3MemShutdown };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3MemShutdown@
identifier F = { sqlite3MemShutdown };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3MemShutdown@
identifier F = { sqlite3MemShutdown };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3MemShutdown@
identifier F = { sqlite3MemShutdown };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3MemShutdown@
F << remove_static_def_brace_same_line_sqlite3MemShutdown.F;
T << remove_static_def_brace_same_line_sqlite3MemShutdown.T;
P << remove_static_def_brace_same_line_sqlite3MemShutdown.P;
p << remove_static_def_brace_same_line_sqlite3MemShutdown.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3MemShutdown@
F << remove_static_def_brace_next_line_sqlite3MemShutdown.F;
T << remove_static_def_brace_next_line_sqlite3MemShutdown.T;
P << remove_static_def_brace_next_line_sqlite3MemShutdown.P;
p << remove_static_def_brace_next_line_sqlite3MemShutdown.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3MemShutdown@
F << remove_static_def_no_type_sqlite3MemShutdown.F;
P << remove_static_def_no_type_sqlite3MemShutdown.P;
p << remove_static_def_no_type_sqlite3MemShutdown.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3MemShutdown@
F << remove_static_decl_with_type_sqlite3MemShutdown.F;
T << remove_static_decl_with_type_sqlite3MemShutdown.T;
P << remove_static_decl_with_type_sqlite3MemShutdown.P;
p << remove_static_decl_with_type_sqlite3MemShutdown.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3MemShutdown@
F << remove_static_inline_sqlite3MemShutdown.F;
T << remove_static_inline_sqlite3MemShutdown.T;
P << remove_static_inline_sqlite3MemShutdown.P;
p << remove_static_inline_sqlite3MemShutdown.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3MemSize
@remove_static_def_brace_same_line_sqlite3MemSize@
identifier F = { sqlite3MemSize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3MemSize@
identifier F = { sqlite3MemSize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3MemSize@
identifier F = { sqlite3MemSize };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3MemSize@
identifier F = { sqlite3MemSize };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3MemSize@
identifier F = { sqlite3MemSize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3MemSize@
F << remove_static_def_brace_same_line_sqlite3MemSize.F;
T << remove_static_def_brace_same_line_sqlite3MemSize.T;
P << remove_static_def_brace_same_line_sqlite3MemSize.P;
p << remove_static_def_brace_same_line_sqlite3MemSize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3MemSize@
F << remove_static_def_brace_next_line_sqlite3MemSize.F;
T << remove_static_def_brace_next_line_sqlite3MemSize.T;
P << remove_static_def_brace_next_line_sqlite3MemSize.P;
p << remove_static_def_brace_next_line_sqlite3MemSize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3MemSize@
F << remove_static_def_no_type_sqlite3MemSize.F;
P << remove_static_def_no_type_sqlite3MemSize.P;
p << remove_static_def_no_type_sqlite3MemSize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3MemSize@
F << remove_static_decl_with_type_sqlite3MemSize.F;
T << remove_static_decl_with_type_sqlite3MemSize.T;
P << remove_static_decl_with_type_sqlite3MemSize.P;
p << remove_static_decl_with_type_sqlite3MemSize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3MemSize@
F << remove_static_inline_sqlite3MemSize.F;
T << remove_static_inline_sqlite3MemSize.T;
P << remove_static_inline_sqlite3MemSize.P;
p << remove_static_inline_sqlite3MemSize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3RtreeInit
@remove_static_def_brace_same_line_sqlite3RtreeInit@
identifier F = { sqlite3RtreeInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3RtreeInit@
identifier F = { sqlite3RtreeInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3RtreeInit@
identifier F = { sqlite3RtreeInit };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3RtreeInit@
identifier F = { sqlite3RtreeInit };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3RtreeInit@
identifier F = { sqlite3RtreeInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3RtreeInit@
F << remove_static_def_brace_same_line_sqlite3RtreeInit.F;
T << remove_static_def_brace_same_line_sqlite3RtreeInit.T;
P << remove_static_def_brace_same_line_sqlite3RtreeInit.P;
p << remove_static_def_brace_same_line_sqlite3RtreeInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3RtreeInit@
F << remove_static_def_brace_next_line_sqlite3RtreeInit.F;
T << remove_static_def_brace_next_line_sqlite3RtreeInit.T;
P << remove_static_def_brace_next_line_sqlite3RtreeInit.P;
p << remove_static_def_brace_next_line_sqlite3RtreeInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3RtreeInit@
F << remove_static_def_no_type_sqlite3RtreeInit.F;
P << remove_static_def_no_type_sqlite3RtreeInit.P;
p << remove_static_def_no_type_sqlite3RtreeInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3RtreeInit@
F << remove_static_decl_with_type_sqlite3RtreeInit.F;
T << remove_static_decl_with_type_sqlite3RtreeInit.T;
P << remove_static_decl_with_type_sqlite3RtreeInit.P;
p << remove_static_decl_with_type_sqlite3RtreeInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3RtreeInit@
F << remove_static_inline_sqlite3RtreeInit.F;
T << remove_static_inline_sqlite3RtreeInit.T;
P << remove_static_inline_sqlite3RtreeInit.P;
p << remove_static_inline_sqlite3RtreeInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3SchemaClear
@remove_static_def_brace_same_line_sqlite3SchemaClear@
identifier F = { sqlite3SchemaClear };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3SchemaClear@
identifier F = { sqlite3SchemaClear };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3SchemaClear@
identifier F = { sqlite3SchemaClear };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3SchemaClear@
identifier F = { sqlite3SchemaClear };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3SchemaClear@
identifier F = { sqlite3SchemaClear };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3SchemaClear@
F << remove_static_def_brace_same_line_sqlite3SchemaClear.F;
T << remove_static_def_brace_same_line_sqlite3SchemaClear.T;
P << remove_static_def_brace_same_line_sqlite3SchemaClear.P;
p << remove_static_def_brace_same_line_sqlite3SchemaClear.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3SchemaClear@
F << remove_static_def_brace_next_line_sqlite3SchemaClear.F;
T << remove_static_def_brace_next_line_sqlite3SchemaClear.T;
P << remove_static_def_brace_next_line_sqlite3SchemaClear.P;
p << remove_static_def_brace_next_line_sqlite3SchemaClear.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3SchemaClear@
F << remove_static_def_no_type_sqlite3SchemaClear.F;
P << remove_static_def_no_type_sqlite3SchemaClear.P;
p << remove_static_def_no_type_sqlite3SchemaClear.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3SchemaClear@
F << remove_static_decl_with_type_sqlite3SchemaClear.F;
T << remove_static_decl_with_type_sqlite3SchemaClear.T;
P << remove_static_decl_with_type_sqlite3SchemaClear.P;
p << remove_static_decl_with_type_sqlite3SchemaClear.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3SchemaClear@
F << remove_static_inline_sqlite3SchemaClear.F;
T << remove_static_inline_sqlite3SchemaClear.T;
P << remove_static_inline_sqlite3SchemaClear.P;
p << remove_static_inline_sqlite3SchemaClear.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3SelectPopWith
@remove_static_def_brace_same_line_sqlite3SelectPopWith@
identifier F = { sqlite3SelectPopWith };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3SelectPopWith@
identifier F = { sqlite3SelectPopWith };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3SelectPopWith@
identifier F = { sqlite3SelectPopWith };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3SelectPopWith@
identifier F = { sqlite3SelectPopWith };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3SelectPopWith@
identifier F = { sqlite3SelectPopWith };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3SelectPopWith@
F << remove_static_def_brace_same_line_sqlite3SelectPopWith.F;
T << remove_static_def_brace_same_line_sqlite3SelectPopWith.T;
P << remove_static_def_brace_same_line_sqlite3SelectPopWith.P;
p << remove_static_def_brace_same_line_sqlite3SelectPopWith.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3SelectPopWith@
F << remove_static_def_brace_next_line_sqlite3SelectPopWith.F;
T << remove_static_def_brace_next_line_sqlite3SelectPopWith.T;
P << remove_static_def_brace_next_line_sqlite3SelectPopWith.P;
p << remove_static_def_brace_next_line_sqlite3SelectPopWith.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3SelectPopWith@
F << remove_static_def_no_type_sqlite3SelectPopWith.F;
P << remove_static_def_no_type_sqlite3SelectPopWith.P;
p << remove_static_def_no_type_sqlite3SelectPopWith.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3SelectPopWith@
F << remove_static_decl_with_type_sqlite3SelectPopWith.F;
T << remove_static_decl_with_type_sqlite3SelectPopWith.T;
P << remove_static_decl_with_type_sqlite3SelectPopWith.P;
p << remove_static_decl_with_type_sqlite3SelectPopWith.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3SelectPopWith@
F << remove_static_inline_sqlite3SelectPopWith.F;
T << remove_static_inline_sqlite3SelectPopWith.T;
P << remove_static_inline_sqlite3SelectPopWith.P;
p << remove_static_inline_sqlite3SelectPopWith.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3SelectWalkNoop
@remove_static_def_brace_same_line_sqlite3SelectWalkNoop@
identifier F = { sqlite3SelectWalkNoop };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3SelectWalkNoop@
identifier F = { sqlite3SelectWalkNoop };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3SelectWalkNoop@
identifier F = { sqlite3SelectWalkNoop };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3SelectWalkNoop@
identifier F = { sqlite3SelectWalkNoop };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3SelectWalkNoop@
identifier F = { sqlite3SelectWalkNoop };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3SelectWalkNoop@
F << remove_static_def_brace_same_line_sqlite3SelectWalkNoop.F;
T << remove_static_def_brace_same_line_sqlite3SelectWalkNoop.T;
P << remove_static_def_brace_same_line_sqlite3SelectWalkNoop.P;
p << remove_static_def_brace_same_line_sqlite3SelectWalkNoop.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3SelectWalkNoop@
F << remove_static_def_brace_next_line_sqlite3SelectWalkNoop.F;
T << remove_static_def_brace_next_line_sqlite3SelectWalkNoop.T;
P << remove_static_def_brace_next_line_sqlite3SelectWalkNoop.P;
p << remove_static_def_brace_next_line_sqlite3SelectWalkNoop.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3SelectWalkNoop@
F << remove_static_def_no_type_sqlite3SelectWalkNoop.F;
P << remove_static_def_no_type_sqlite3SelectWalkNoop.P;
p << remove_static_def_no_type_sqlite3SelectWalkNoop.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3SelectWalkNoop@
F << remove_static_decl_with_type_sqlite3SelectWalkNoop.F;
T << remove_static_decl_with_type_sqlite3SelectWalkNoop.T;
P << remove_static_decl_with_type_sqlite3SelectWalkNoop.P;
p << remove_static_decl_with_type_sqlite3SelectWalkNoop.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3SelectWalkNoop@
F << remove_static_inline_sqlite3SelectWalkNoop.F;
T << remove_static_inline_sqlite3SelectWalkNoop.T;
P << remove_static_inline_sqlite3SelectWalkNoop.P;
p << remove_static_inline_sqlite3SelectWalkNoop.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3StmtVtabInit
@remove_static_def_brace_same_line_sqlite3StmtVtabInit@
identifier F = { sqlite3StmtVtabInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3StmtVtabInit@
identifier F = { sqlite3StmtVtabInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3StmtVtabInit@
identifier F = { sqlite3StmtVtabInit };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3StmtVtabInit@
identifier F = { sqlite3StmtVtabInit };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3StmtVtabInit@
identifier F = { sqlite3StmtVtabInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3StmtVtabInit@
F << remove_static_def_brace_same_line_sqlite3StmtVtabInit.F;
T << remove_static_def_brace_same_line_sqlite3StmtVtabInit.T;
P << remove_static_def_brace_same_line_sqlite3StmtVtabInit.P;
p << remove_static_def_brace_same_line_sqlite3StmtVtabInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3StmtVtabInit@
F << remove_static_def_brace_next_line_sqlite3StmtVtabInit.F;
T << remove_static_def_brace_next_line_sqlite3StmtVtabInit.T;
P << remove_static_def_brace_next_line_sqlite3StmtVtabInit.P;
p << remove_static_def_brace_next_line_sqlite3StmtVtabInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3StmtVtabInit@
F << remove_static_def_no_type_sqlite3StmtVtabInit.F;
P << remove_static_def_no_type_sqlite3StmtVtabInit.P;
p << remove_static_def_no_type_sqlite3StmtVtabInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3StmtVtabInit@
F << remove_static_decl_with_type_sqlite3StmtVtabInit.F;
T << remove_static_decl_with_type_sqlite3StmtVtabInit.T;
P << remove_static_decl_with_type_sqlite3StmtVtabInit.P;
p << remove_static_decl_with_type_sqlite3StmtVtabInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3StmtVtabInit@
F << remove_static_inline_sqlite3StmtVtabInit.F;
T << remove_static_inline_sqlite3StmtVtabInit.T;
P << remove_static_inline_sqlite3StmtVtabInit.P;
p << remove_static_inline_sqlite3StmtVtabInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3TestExtInit
@remove_static_def_brace_same_line_sqlite3TestExtInit@
identifier F = { sqlite3TestExtInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3TestExtInit@
identifier F = { sqlite3TestExtInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3TestExtInit@
identifier F = { sqlite3TestExtInit };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3TestExtInit@
identifier F = { sqlite3TestExtInit };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3TestExtInit@
identifier F = { sqlite3TestExtInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3TestExtInit@
F << remove_static_def_brace_same_line_sqlite3TestExtInit.F;
T << remove_static_def_brace_same_line_sqlite3TestExtInit.T;
P << remove_static_def_brace_same_line_sqlite3TestExtInit.P;
p << remove_static_def_brace_same_line_sqlite3TestExtInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3TestExtInit@
F << remove_static_def_brace_next_line_sqlite3TestExtInit.F;
T << remove_static_def_brace_next_line_sqlite3TestExtInit.T;
P << remove_static_def_brace_next_line_sqlite3TestExtInit.P;
p << remove_static_def_brace_next_line_sqlite3TestExtInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3TestExtInit@
F << remove_static_def_no_type_sqlite3TestExtInit.F;
P << remove_static_def_no_type_sqlite3TestExtInit.P;
p << remove_static_def_no_type_sqlite3TestExtInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3TestExtInit@
F << remove_static_decl_with_type_sqlite3TestExtInit.F;
T << remove_static_decl_with_type_sqlite3TestExtInit.T;
P << remove_static_decl_with_type_sqlite3TestExtInit.P;
p << remove_static_decl_with_type_sqlite3TestExtInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3TestExtInit@
F << remove_static_inline_sqlite3TestExtInit.F;
T << remove_static_inline_sqlite3TestExtInit.T;
P << remove_static_inline_sqlite3TestExtInit.P;
p << remove_static_inline_sqlite3TestExtInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3VdbeBytecodeVtabInit
@remove_static_def_brace_same_line_sqlite3VdbeBytecodeVtabInit@
identifier F = { sqlite3VdbeBytecodeVtabInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3VdbeBytecodeVtabInit@
identifier F = { sqlite3VdbeBytecodeVtabInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3VdbeBytecodeVtabInit@
identifier F = { sqlite3VdbeBytecodeVtabInit };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3VdbeBytecodeVtabInit@
identifier F = { sqlite3VdbeBytecodeVtabInit };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3VdbeBytecodeVtabInit@
identifier F = { sqlite3VdbeBytecodeVtabInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3VdbeBytecodeVtabInit@
F << remove_static_def_brace_same_line_sqlite3VdbeBytecodeVtabInit.F;
T << remove_static_def_brace_same_line_sqlite3VdbeBytecodeVtabInit.T;
P << remove_static_def_brace_same_line_sqlite3VdbeBytecodeVtabInit.P;
p << remove_static_def_brace_same_line_sqlite3VdbeBytecodeVtabInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3VdbeBytecodeVtabInit@
F << remove_static_def_brace_next_line_sqlite3VdbeBytecodeVtabInit.F;
T << remove_static_def_brace_next_line_sqlite3VdbeBytecodeVtabInit.T;
P << remove_static_def_brace_next_line_sqlite3VdbeBytecodeVtabInit.P;
p << remove_static_def_brace_next_line_sqlite3VdbeBytecodeVtabInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3VdbeBytecodeVtabInit@
F << remove_static_def_no_type_sqlite3VdbeBytecodeVtabInit.F;
P << remove_static_def_no_type_sqlite3VdbeBytecodeVtabInit.P;
p << remove_static_def_no_type_sqlite3VdbeBytecodeVtabInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3VdbeBytecodeVtabInit@
F << remove_static_decl_with_type_sqlite3VdbeBytecodeVtabInit.F;
T << remove_static_decl_with_type_sqlite3VdbeBytecodeVtabInit.T;
P << remove_static_decl_with_type_sqlite3VdbeBytecodeVtabInit.P;
p << remove_static_decl_with_type_sqlite3VdbeBytecodeVtabInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3VdbeBytecodeVtabInit@
F << remove_static_inline_sqlite3VdbeBytecodeVtabInit.F;
T << remove_static_inline_sqlite3VdbeBytecodeVtabInit.T;
P << remove_static_inline_sqlite3VdbeBytecodeVtabInit.P;
p << remove_static_inline_sqlite3VdbeBytecodeVtabInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3WalkWinDefnDummyCallback
@remove_static_def_brace_same_line_sqlite3WalkWinDefnDummyCallback@
identifier F = { sqlite3WalkWinDefnDummyCallback };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3WalkWinDefnDummyCallback@
identifier F = { sqlite3WalkWinDefnDummyCallback };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3WalkWinDefnDummyCallback@
identifier F = { sqlite3WalkWinDefnDummyCallback };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3WalkWinDefnDummyCallback@
identifier F = { sqlite3WalkWinDefnDummyCallback };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3WalkWinDefnDummyCallback@
identifier F = { sqlite3WalkWinDefnDummyCallback };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3WalkWinDefnDummyCallback@
F << remove_static_def_brace_same_line_sqlite3WalkWinDefnDummyCallback.F;
T << remove_static_def_brace_same_line_sqlite3WalkWinDefnDummyCallback.T;
P << remove_static_def_brace_same_line_sqlite3WalkWinDefnDummyCallback.P;
p << remove_static_def_brace_same_line_sqlite3WalkWinDefnDummyCallback.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3WalkWinDefnDummyCallback@
F << remove_static_def_brace_next_line_sqlite3WalkWinDefnDummyCallback.F;
T << remove_static_def_brace_next_line_sqlite3WalkWinDefnDummyCallback.T;
P << remove_static_def_brace_next_line_sqlite3WalkWinDefnDummyCallback.P;
p << remove_static_def_brace_next_line_sqlite3WalkWinDefnDummyCallback.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3WalkWinDefnDummyCallback@
F << remove_static_def_no_type_sqlite3WalkWinDefnDummyCallback.F;
P << remove_static_def_no_type_sqlite3WalkWinDefnDummyCallback.P;
p << remove_static_def_no_type_sqlite3WalkWinDefnDummyCallback.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3WalkWinDefnDummyCallback@
F << remove_static_decl_with_type_sqlite3WalkWinDefnDummyCallback.F;
T << remove_static_decl_with_type_sqlite3WalkWinDefnDummyCallback.T;
P << remove_static_decl_with_type_sqlite3WalkWinDefnDummyCallback.P;
p << remove_static_decl_with_type_sqlite3WalkWinDefnDummyCallback.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3WalkWinDefnDummyCallback@
F << remove_static_inline_sqlite3WalkWinDefnDummyCallback.F;
T << remove_static_inline_sqlite3WalkWinDefnDummyCallback.T;
P << remove_static_inline_sqlite3WalkWinDefnDummyCallback.P;
p << remove_static_inline_sqlite3WalkWinDefnDummyCallback.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3WalkerDepthDecrease
@remove_static_def_brace_same_line_sqlite3WalkerDepthDecrease@
identifier F = { sqlite3WalkerDepthDecrease };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3WalkerDepthDecrease@
identifier F = { sqlite3WalkerDepthDecrease };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3WalkerDepthDecrease@
identifier F = { sqlite3WalkerDepthDecrease };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3WalkerDepthDecrease@
identifier F = { sqlite3WalkerDepthDecrease };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3WalkerDepthDecrease@
identifier F = { sqlite3WalkerDepthDecrease };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3WalkerDepthDecrease@
F << remove_static_def_brace_same_line_sqlite3WalkerDepthDecrease.F;
T << remove_static_def_brace_same_line_sqlite3WalkerDepthDecrease.T;
P << remove_static_def_brace_same_line_sqlite3WalkerDepthDecrease.P;
p << remove_static_def_brace_same_line_sqlite3WalkerDepthDecrease.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3WalkerDepthDecrease@
F << remove_static_def_brace_next_line_sqlite3WalkerDepthDecrease.F;
T << remove_static_def_brace_next_line_sqlite3WalkerDepthDecrease.T;
P << remove_static_def_brace_next_line_sqlite3WalkerDepthDecrease.P;
p << remove_static_def_brace_next_line_sqlite3WalkerDepthDecrease.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3WalkerDepthDecrease@
F << remove_static_def_no_type_sqlite3WalkerDepthDecrease.F;
P << remove_static_def_no_type_sqlite3WalkerDepthDecrease.P;
p << remove_static_def_no_type_sqlite3WalkerDepthDecrease.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3WalkerDepthDecrease@
F << remove_static_decl_with_type_sqlite3WalkerDepthDecrease.F;
T << remove_static_decl_with_type_sqlite3WalkerDepthDecrease.T;
P << remove_static_decl_with_type_sqlite3WalkerDepthDecrease.P;
p << remove_static_decl_with_type_sqlite3WalkerDepthDecrease.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3WalkerDepthDecrease@
F << remove_static_inline_sqlite3WalkerDepthDecrease.F;
T << remove_static_inline_sqlite3WalkerDepthDecrease.T;
P << remove_static_inline_sqlite3WalkerDepthDecrease.P;
p << remove_static_inline_sqlite3WalkerDepthDecrease.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3WalkerDepthIncrease
@remove_static_def_brace_same_line_sqlite3WalkerDepthIncrease@
identifier F = { sqlite3WalkerDepthIncrease };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3WalkerDepthIncrease@
identifier F = { sqlite3WalkerDepthIncrease };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3WalkerDepthIncrease@
identifier F = { sqlite3WalkerDepthIncrease };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3WalkerDepthIncrease@
identifier F = { sqlite3WalkerDepthIncrease };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3WalkerDepthIncrease@
identifier F = { sqlite3WalkerDepthIncrease };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3WalkerDepthIncrease@
F << remove_static_def_brace_same_line_sqlite3WalkerDepthIncrease.F;
T << remove_static_def_brace_same_line_sqlite3WalkerDepthIncrease.T;
P << remove_static_def_brace_same_line_sqlite3WalkerDepthIncrease.P;
p << remove_static_def_brace_same_line_sqlite3WalkerDepthIncrease.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3WalkerDepthIncrease@
F << remove_static_def_brace_next_line_sqlite3WalkerDepthIncrease.F;
T << remove_static_def_brace_next_line_sqlite3WalkerDepthIncrease.T;
P << remove_static_def_brace_next_line_sqlite3WalkerDepthIncrease.P;
p << remove_static_def_brace_next_line_sqlite3WalkerDepthIncrease.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3WalkerDepthIncrease@
F << remove_static_def_no_type_sqlite3WalkerDepthIncrease.F;
P << remove_static_def_no_type_sqlite3WalkerDepthIncrease.P;
p << remove_static_def_no_type_sqlite3WalkerDepthIncrease.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3WalkerDepthIncrease@
F << remove_static_decl_with_type_sqlite3WalkerDepthIncrease.F;
T << remove_static_decl_with_type_sqlite3WalkerDepthIncrease.T;
P << remove_static_decl_with_type_sqlite3WalkerDepthIncrease.P;
p << remove_static_decl_with_type_sqlite3WalkerDepthIncrease.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3WalkerDepthIncrease@
F << remove_static_inline_sqlite3WalkerDepthIncrease.F;
T << remove_static_inline_sqlite3WalkerDepthIncrease.T;
P << remove_static_inline_sqlite3WalkerDepthIncrease.P;
p << remove_static_inline_sqlite3WalkerDepthIncrease.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3WindowExtraAggFuncDepth
@remove_static_def_brace_same_line_sqlite3WindowExtraAggFuncDepth@
identifier F = { sqlite3WindowExtraAggFuncDepth };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3WindowExtraAggFuncDepth@
identifier F = { sqlite3WindowExtraAggFuncDepth };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3WindowExtraAggFuncDepth@
identifier F = { sqlite3WindowExtraAggFuncDepth };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3WindowExtraAggFuncDepth@
identifier F = { sqlite3WindowExtraAggFuncDepth };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3WindowExtraAggFuncDepth@
identifier F = { sqlite3WindowExtraAggFuncDepth };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3WindowExtraAggFuncDepth@
F << remove_static_def_brace_same_line_sqlite3WindowExtraAggFuncDepth.F;
T << remove_static_def_brace_same_line_sqlite3WindowExtraAggFuncDepth.T;
P << remove_static_def_brace_same_line_sqlite3WindowExtraAggFuncDepth.P;
p << remove_static_def_brace_same_line_sqlite3WindowExtraAggFuncDepth.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3WindowExtraAggFuncDepth@
F << remove_static_def_brace_next_line_sqlite3WindowExtraAggFuncDepth.F;
T << remove_static_def_brace_next_line_sqlite3WindowExtraAggFuncDepth.T;
P << remove_static_def_brace_next_line_sqlite3WindowExtraAggFuncDepth.P;
p << remove_static_def_brace_next_line_sqlite3WindowExtraAggFuncDepth.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3WindowExtraAggFuncDepth@
F << remove_static_def_no_type_sqlite3WindowExtraAggFuncDepth.F;
P << remove_static_def_no_type_sqlite3WindowExtraAggFuncDepth.P;
p << remove_static_def_no_type_sqlite3WindowExtraAggFuncDepth.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3WindowExtraAggFuncDepth@
F << remove_static_decl_with_type_sqlite3WindowExtraAggFuncDepth.F;
T << remove_static_decl_with_type_sqlite3WindowExtraAggFuncDepth.T;
P << remove_static_decl_with_type_sqlite3WindowExtraAggFuncDepth.P;
p << remove_static_decl_with_type_sqlite3WindowExtraAggFuncDepth.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3WindowExtraAggFuncDepth@
F << remove_static_inline_sqlite3WindowExtraAggFuncDepth.F;
T << remove_static_inline_sqlite3WindowExtraAggFuncDepth.T;
P << remove_static_inline_sqlite3WindowExtraAggFuncDepth.P;
p << remove_static_inline_sqlite3WindowExtraAggFuncDepth.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sqlite3_free
@remove_static_def_brace_same_line_sqlite3_free@
identifier F = { sqlite3_free };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sqlite3_free@
identifier F = { sqlite3_free };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sqlite3_free@
identifier F = { sqlite3_free };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sqlite3_free@
identifier F = { sqlite3_free };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sqlite3_free@
identifier F = { sqlite3_free };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sqlite3_free@
F << remove_static_def_brace_same_line_sqlite3_free.F;
T << remove_static_def_brace_same_line_sqlite3_free.T;
P << remove_static_def_brace_same_line_sqlite3_free.P;
p << remove_static_def_brace_same_line_sqlite3_free.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sqlite3_free@
F << remove_static_def_brace_next_line_sqlite3_free.F;
T << remove_static_def_brace_next_line_sqlite3_free.T;
P << remove_static_def_brace_next_line_sqlite3_free.P;
p << remove_static_def_brace_next_line_sqlite3_free.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sqlite3_free@
F << remove_static_def_no_type_sqlite3_free.F;
P << remove_static_def_no_type_sqlite3_free.P;
p << remove_static_def_no_type_sqlite3_free.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sqlite3_free@
F << remove_static_decl_with_type_sqlite3_free.F;
T << remove_static_decl_with_type_sqlite3_free.T;
P << remove_static_decl_with_type_sqlite3_free.P;
p << remove_static_decl_with_type_sqlite3_free.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sqlite3_free@
F << remove_static_inline_sqlite3_free.F;
T << remove_static_inline_sqlite3_free.T;
P << remove_static_inline_sqlite3_free.P;
p << remove_static_inline_sqlite3_free.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: statAccumDestructor
@remove_static_def_brace_same_line_statAccumDestructor@
identifier F = { statAccumDestructor };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_statAccumDestructor@
identifier F = { statAccumDestructor };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_statAccumDestructor@
identifier F = { statAccumDestructor };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_statAccumDestructor@
identifier F = { statAccumDestructor };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_statAccumDestructor@
identifier F = { statAccumDestructor };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_statAccumDestructor@
F << remove_static_def_brace_same_line_statAccumDestructor.F;
T << remove_static_def_brace_same_line_statAccumDestructor.T;
P << remove_static_def_brace_same_line_statAccumDestructor.P;
p << remove_static_def_brace_same_line_statAccumDestructor.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_statAccumDestructor@
F << remove_static_def_brace_next_line_statAccumDestructor.F;
T << remove_static_def_brace_next_line_statAccumDestructor.T;
P << remove_static_def_brace_next_line_statAccumDestructor.P;
p << remove_static_def_brace_next_line_statAccumDestructor.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_statAccumDestructor@
F << remove_static_def_no_type_statAccumDestructor.F;
P << remove_static_def_no_type_statAccumDestructor.P;
p << remove_static_def_no_type_statAccumDestructor.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_statAccumDestructor@
F << remove_static_decl_with_type_statAccumDestructor.F;
T << remove_static_decl_with_type_statAccumDestructor.T;
P << remove_static_decl_with_type_statAccumDestructor.P;
p << remove_static_decl_with_type_statAccumDestructor.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_statAccumDestructor@
F << remove_static_inline_statAccumDestructor.F;
T << remove_static_inline_statAccumDestructor.T;
P << remove_static_inline_statAccumDestructor.P;
p << remove_static_inline_statAccumDestructor.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: statGet
@remove_static_def_brace_same_line_statGet@
identifier F = { statGet };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_statGet@
identifier F = { statGet };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_statGet@
identifier F = { statGet };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_statGet@
identifier F = { statGet };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_statGet@
identifier F = { statGet };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_statGet@
F << remove_static_def_brace_same_line_statGet.F;
T << remove_static_def_brace_same_line_statGet.T;
P << remove_static_def_brace_same_line_statGet.P;
p << remove_static_def_brace_same_line_statGet.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_statGet@
F << remove_static_def_brace_next_line_statGet.F;
T << remove_static_def_brace_next_line_statGet.T;
P << remove_static_def_brace_next_line_statGet.P;
p << remove_static_def_brace_next_line_statGet.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_statGet@
F << remove_static_def_no_type_statGet.F;
P << remove_static_def_no_type_statGet.P;
p << remove_static_def_no_type_statGet.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_statGet@
F << remove_static_decl_with_type_statGet.F;
T << remove_static_decl_with_type_statGet.T;
P << remove_static_decl_with_type_statGet.P;
p << remove_static_decl_with_type_statGet.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_statGet@
F << remove_static_inline_statGet.F;
T << remove_static_inline_statGet.T;
P << remove_static_inline_statGet.P;
p << remove_static_inline_statGet.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: statInit
@remove_static_def_brace_same_line_statInit@
identifier F = { statInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_statInit@
identifier F = { statInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_statInit@
identifier F = { statInit };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_statInit@
identifier F = { statInit };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_statInit@
identifier F = { statInit };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_statInit@
F << remove_static_def_brace_same_line_statInit.F;
T << remove_static_def_brace_same_line_statInit.T;
P << remove_static_def_brace_same_line_statInit.P;
p << remove_static_def_brace_same_line_statInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_statInit@
F << remove_static_def_brace_next_line_statInit.F;
T << remove_static_def_brace_next_line_statInit.T;
P << remove_static_def_brace_next_line_statInit.P;
p << remove_static_def_brace_next_line_statInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_statInit@
F << remove_static_def_no_type_statInit.F;
P << remove_static_def_no_type_statInit.P;
p << remove_static_def_no_type_statInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_statInit@
F << remove_static_decl_with_type_statInit.F;
T << remove_static_decl_with_type_statInit.T;
P << remove_static_decl_with_type_statInit.P;
p << remove_static_decl_with_type_statInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_statInit@
F << remove_static_inline_statInit.F;
T << remove_static_inline_statInit.T;
P << remove_static_inline_statInit.P;
p << remove_static_inline_statInit.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: statPush
@remove_static_def_brace_same_line_statPush@
identifier F = { statPush };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_statPush@
identifier F = { statPush };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_statPush@
identifier F = { statPush };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_statPush@
identifier F = { statPush };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_statPush@
identifier F = { statPush };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_statPush@
F << remove_static_def_brace_same_line_statPush.F;
T << remove_static_def_brace_same_line_statPush.T;
P << remove_static_def_brace_same_line_statPush.P;
p << remove_static_def_brace_same_line_statPush.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_statPush@
F << remove_static_def_brace_next_line_statPush.F;
T << remove_static_def_brace_next_line_statPush.T;
P << remove_static_def_brace_next_line_statPush.P;
p << remove_static_def_brace_next_line_statPush.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_statPush@
F << remove_static_def_no_type_statPush.F;
P << remove_static_def_no_type_statPush.P;
p << remove_static_def_no_type_statPush.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_statPush@
F << remove_static_decl_with_type_statPush.F;
T << remove_static_decl_with_type_statPush.T;
P << remove_static_decl_with_type_statPush.P;
p << remove_static_decl_with_type_statPush.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_statPush@
F << remove_static_inline_statPush.F;
T << remove_static_inline_statPush.T;
P << remove_static_inline_statPush.P;
p << remove_static_inline_statPush.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: strftimeFunc
@remove_static_def_brace_same_line_strftimeFunc@
identifier F = { strftimeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_strftimeFunc@
identifier F = { strftimeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_strftimeFunc@
identifier F = { strftimeFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_strftimeFunc@
identifier F = { strftimeFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_strftimeFunc@
identifier F = { strftimeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_strftimeFunc@
F << remove_static_def_brace_same_line_strftimeFunc.F;
T << remove_static_def_brace_same_line_strftimeFunc.T;
P << remove_static_def_brace_same_line_strftimeFunc.P;
p << remove_static_def_brace_same_line_strftimeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_strftimeFunc@
F << remove_static_def_brace_next_line_strftimeFunc.F;
T << remove_static_def_brace_next_line_strftimeFunc.T;
P << remove_static_def_brace_next_line_strftimeFunc.P;
p << remove_static_def_brace_next_line_strftimeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_strftimeFunc@
F << remove_static_def_no_type_strftimeFunc.F;
P << remove_static_def_no_type_strftimeFunc.P;
p << remove_static_def_no_type_strftimeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_strftimeFunc@
F << remove_static_decl_with_type_strftimeFunc.F;
T << remove_static_decl_with_type_strftimeFunc.T;
P << remove_static_decl_with_type_strftimeFunc.P;
p << remove_static_decl_with_type_strftimeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_strftimeFunc@
F << remove_static_inline_strftimeFunc.F;
T << remove_static_inline_strftimeFunc.T;
P << remove_static_inline_strftimeFunc.P;
p << remove_static_inline_strftimeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: substrFunc
@remove_static_def_brace_same_line_substrFunc@
identifier F = { substrFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_substrFunc@
identifier F = { substrFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_substrFunc@
identifier F = { substrFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_substrFunc@
identifier F = { substrFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_substrFunc@
identifier F = { substrFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_substrFunc@
F << remove_static_def_brace_same_line_substrFunc.F;
T << remove_static_def_brace_same_line_substrFunc.T;
P << remove_static_def_brace_same_line_substrFunc.P;
p << remove_static_def_brace_same_line_substrFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_substrFunc@
F << remove_static_def_brace_next_line_substrFunc.F;
T << remove_static_def_brace_next_line_substrFunc.T;
P << remove_static_def_brace_next_line_substrFunc.P;
p << remove_static_def_brace_next_line_substrFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_substrFunc@
F << remove_static_def_no_type_substrFunc.F;
P << remove_static_def_no_type_substrFunc.P;
p << remove_static_def_no_type_substrFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_substrFunc@
F << remove_static_decl_with_type_substrFunc.F;
T << remove_static_decl_with_type_substrFunc.T;
P << remove_static_decl_with_type_substrFunc.P;
p << remove_static_decl_with_type_substrFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_substrFunc@
F << remove_static_inline_substrFunc.F;
T << remove_static_inline_substrFunc.T;
P << remove_static_inline_substrFunc.P;
p << remove_static_inline_substrFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sumFinalize
@remove_static_def_brace_same_line_sumFinalize@
identifier F = { sumFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sumFinalize@
identifier F = { sumFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sumFinalize@
identifier F = { sumFinalize };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sumFinalize@
identifier F = { sumFinalize };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sumFinalize@
identifier F = { sumFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sumFinalize@
F << remove_static_def_brace_same_line_sumFinalize.F;
T << remove_static_def_brace_same_line_sumFinalize.T;
P << remove_static_def_brace_same_line_sumFinalize.P;
p << remove_static_def_brace_same_line_sumFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sumFinalize@
F << remove_static_def_brace_next_line_sumFinalize.F;
T << remove_static_def_brace_next_line_sumFinalize.T;
P << remove_static_def_brace_next_line_sumFinalize.P;
p << remove_static_def_brace_next_line_sumFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sumFinalize@
F << remove_static_def_no_type_sumFinalize.F;
P << remove_static_def_no_type_sumFinalize.P;
p << remove_static_def_no_type_sumFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sumFinalize@
F << remove_static_decl_with_type_sumFinalize.F;
T << remove_static_decl_with_type_sumFinalize.T;
P << remove_static_decl_with_type_sumFinalize.P;
p << remove_static_decl_with_type_sumFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sumFinalize@
F << remove_static_inline_sumFinalize.F;
T << remove_static_inline_sumFinalize.T;
P << remove_static_inline_sumFinalize.P;
p << remove_static_inline_sumFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: sumStep
@remove_static_def_brace_same_line_sumStep@
identifier F = { sumStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_sumStep@
identifier F = { sumStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_sumStep@
identifier F = { sumStep };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_sumStep@
identifier F = { sumStep };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_sumStep@
identifier F = { sumStep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_sumStep@
F << remove_static_def_brace_same_line_sumStep.F;
T << remove_static_def_brace_same_line_sumStep.T;
P << remove_static_def_brace_same_line_sumStep.P;
p << remove_static_def_brace_same_line_sumStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_sumStep@
F << remove_static_def_brace_next_line_sumStep.F;
T << remove_static_def_brace_next_line_sumStep.T;
P << remove_static_def_brace_next_line_sumStep.P;
p << remove_static_def_brace_next_line_sumStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_sumStep@
F << remove_static_def_no_type_sumStep.F;
P << remove_static_def_no_type_sumStep.P;
p << remove_static_def_no_type_sumStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_sumStep@
F << remove_static_decl_with_type_sumStep.F;
T << remove_static_decl_with_type_sumStep.T;
P << remove_static_decl_with_type_sumStep.P;
p << remove_static_decl_with_type_sumStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_sumStep@
F << remove_static_inline_sumStep.F;
T << remove_static_inline_sumStep.T;
P << remove_static_inline_sumStep.P;
p << remove_static_inline_sumStep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: timeFunc
@remove_static_def_brace_same_line_timeFunc@
identifier F = { timeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_timeFunc@
identifier F = { timeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_timeFunc@
identifier F = { timeFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_timeFunc@
identifier F = { timeFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_timeFunc@
identifier F = { timeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_timeFunc@
F << remove_static_def_brace_same_line_timeFunc.F;
T << remove_static_def_brace_same_line_timeFunc.T;
P << remove_static_def_brace_same_line_timeFunc.P;
p << remove_static_def_brace_same_line_timeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_timeFunc@
F << remove_static_def_brace_next_line_timeFunc.F;
T << remove_static_def_brace_next_line_timeFunc.T;
P << remove_static_def_brace_next_line_timeFunc.P;
p << remove_static_def_brace_next_line_timeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_timeFunc@
F << remove_static_def_no_type_timeFunc.F;
P << remove_static_def_no_type_timeFunc.P;
p << remove_static_def_no_type_timeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_timeFunc@
F << remove_static_decl_with_type_timeFunc.F;
T << remove_static_decl_with_type_timeFunc.T;
P << remove_static_decl_with_type_timeFunc.P;
p << remove_static_decl_with_type_timeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_timeFunc@
F << remove_static_inline_timeFunc.F;
T << remove_static_inline_timeFunc.T;
P << remove_static_inline_timeFunc.P;
p << remove_static_inline_timeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: totalFinalize
@remove_static_def_brace_same_line_totalFinalize@
identifier F = { totalFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_totalFinalize@
identifier F = { totalFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_totalFinalize@
identifier F = { totalFinalize };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_totalFinalize@
identifier F = { totalFinalize };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_totalFinalize@
identifier F = { totalFinalize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_totalFinalize@
F << remove_static_def_brace_same_line_totalFinalize.F;
T << remove_static_def_brace_same_line_totalFinalize.T;
P << remove_static_def_brace_same_line_totalFinalize.P;
p << remove_static_def_brace_same_line_totalFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_totalFinalize@
F << remove_static_def_brace_next_line_totalFinalize.F;
T << remove_static_def_brace_next_line_totalFinalize.T;
P << remove_static_def_brace_next_line_totalFinalize.P;
p << remove_static_def_brace_next_line_totalFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_totalFinalize@
F << remove_static_def_no_type_totalFinalize.F;
P << remove_static_def_no_type_totalFinalize.P;
p << remove_static_def_no_type_totalFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_totalFinalize@
F << remove_static_decl_with_type_totalFinalize.F;
T << remove_static_decl_with_type_totalFinalize.T;
P << remove_static_decl_with_type_totalFinalize.P;
p << remove_static_decl_with_type_totalFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_totalFinalize@
F << remove_static_inline_totalFinalize.F;
T << remove_static_inline_totalFinalize.T;
P << remove_static_inline_totalFinalize.P;
p << remove_static_inline_totalFinalize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: total_changes
@remove_static_def_brace_same_line_total_changes@
identifier F = { total_changes };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_total_changes@
identifier F = { total_changes };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_total_changes@
identifier F = { total_changes };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_total_changes@
identifier F = { total_changes };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_total_changes@
identifier F = { total_changes };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_total_changes@
F << remove_static_def_brace_same_line_total_changes.F;
T << remove_static_def_brace_same_line_total_changes.T;
P << remove_static_def_brace_same_line_total_changes.P;
p << remove_static_def_brace_same_line_total_changes.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_total_changes@
F << remove_static_def_brace_next_line_total_changes.F;
T << remove_static_def_brace_next_line_total_changes.T;
P << remove_static_def_brace_next_line_total_changes.P;
p << remove_static_def_brace_next_line_total_changes.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_total_changes@
F << remove_static_def_no_type_total_changes.F;
P << remove_static_def_no_type_total_changes.P;
p << remove_static_def_no_type_total_changes.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_total_changes@
F << remove_static_decl_with_type_total_changes.F;
T << remove_static_decl_with_type_total_changes.T;
P << remove_static_decl_with_type_total_changes.P;
p << remove_static_decl_with_type_total_changes.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_total_changes@
F << remove_static_inline_total_changes.F;
T << remove_static_inline_total_changes.T;
P << remove_static_inline_total_changes.P;
p << remove_static_inline_total_changes.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: trimFunc
@remove_static_def_brace_same_line_trimFunc@
identifier F = { trimFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_trimFunc@
identifier F = { trimFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_trimFunc@
identifier F = { trimFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_trimFunc@
identifier F = { trimFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_trimFunc@
identifier F = { trimFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_trimFunc@
F << remove_static_def_brace_same_line_trimFunc.F;
T << remove_static_def_brace_same_line_trimFunc.T;
P << remove_static_def_brace_same_line_trimFunc.P;
p << remove_static_def_brace_same_line_trimFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_trimFunc@
F << remove_static_def_brace_next_line_trimFunc.F;
T << remove_static_def_brace_next_line_trimFunc.T;
P << remove_static_def_brace_next_line_trimFunc.P;
p << remove_static_def_brace_next_line_trimFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_trimFunc@
F << remove_static_def_no_type_trimFunc.F;
P << remove_static_def_no_type_trimFunc.P;
p << remove_static_def_no_type_trimFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_trimFunc@
F << remove_static_decl_with_type_trimFunc.F;
T << remove_static_decl_with_type_trimFunc.T;
P << remove_static_decl_with_type_trimFunc.P;
p << remove_static_decl_with_type_trimFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_trimFunc@
F << remove_static_inline_trimFunc.F;
T << remove_static_inline_trimFunc.T;
P << remove_static_inline_trimFunc.P;
p << remove_static_inline_trimFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: typeofFunc
@remove_static_def_brace_same_line_typeofFunc@
identifier F = { typeofFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_typeofFunc@
identifier F = { typeofFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_typeofFunc@
identifier F = { typeofFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_typeofFunc@
identifier F = { typeofFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_typeofFunc@
identifier F = { typeofFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_typeofFunc@
F << remove_static_def_brace_same_line_typeofFunc.F;
T << remove_static_def_brace_same_line_typeofFunc.T;
P << remove_static_def_brace_same_line_typeofFunc.P;
p << remove_static_def_brace_same_line_typeofFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_typeofFunc@
F << remove_static_def_brace_next_line_typeofFunc.F;
T << remove_static_def_brace_next_line_typeofFunc.T;
P << remove_static_def_brace_next_line_typeofFunc.P;
p << remove_static_def_brace_next_line_typeofFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_typeofFunc@
F << remove_static_def_no_type_typeofFunc.F;
P << remove_static_def_no_type_typeofFunc.P;
p << remove_static_def_no_type_typeofFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_typeofFunc@
F << remove_static_decl_with_type_typeofFunc.F;
T << remove_static_decl_with_type_typeofFunc.T;
P << remove_static_decl_with_type_typeofFunc.P;
p << remove_static_decl_with_type_typeofFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_typeofFunc@
F << remove_static_inline_typeofFunc.F;
T << remove_static_inline_typeofFunc.T;
P << remove_static_inline_typeofFunc.P;
p << remove_static_inline_typeofFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unhexFunc
@remove_static_def_brace_same_line_unhexFunc@
identifier F = { unhexFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unhexFunc@
identifier F = { unhexFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unhexFunc@
identifier F = { unhexFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unhexFunc@
identifier F = { unhexFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unhexFunc@
identifier F = { unhexFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unhexFunc@
F << remove_static_def_brace_same_line_unhexFunc.F;
T << remove_static_def_brace_same_line_unhexFunc.T;
P << remove_static_def_brace_same_line_unhexFunc.P;
p << remove_static_def_brace_same_line_unhexFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unhexFunc@
F << remove_static_def_brace_next_line_unhexFunc.F;
T << remove_static_def_brace_next_line_unhexFunc.T;
P << remove_static_def_brace_next_line_unhexFunc.P;
p << remove_static_def_brace_next_line_unhexFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unhexFunc@
F << remove_static_def_no_type_unhexFunc.F;
P << remove_static_def_no_type_unhexFunc.P;
p << remove_static_def_no_type_unhexFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unhexFunc@
F << remove_static_decl_with_type_unhexFunc.F;
T << remove_static_decl_with_type_unhexFunc.T;
P << remove_static_decl_with_type_unhexFunc.P;
p << remove_static_decl_with_type_unhexFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unhexFunc@
F << remove_static_inline_unhexFunc.F;
T << remove_static_inline_unhexFunc.T;
P << remove_static_inline_unhexFunc.P;
p << remove_static_inline_unhexFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unicodeFunc
@remove_static_def_brace_same_line_unicodeFunc@
identifier F = { unicodeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unicodeFunc@
identifier F = { unicodeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unicodeFunc@
identifier F = { unicodeFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unicodeFunc@
identifier F = { unicodeFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unicodeFunc@
identifier F = { unicodeFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unicodeFunc@
F << remove_static_def_brace_same_line_unicodeFunc.F;
T << remove_static_def_brace_same_line_unicodeFunc.T;
P << remove_static_def_brace_same_line_unicodeFunc.P;
p << remove_static_def_brace_same_line_unicodeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unicodeFunc@
F << remove_static_def_brace_next_line_unicodeFunc.F;
T << remove_static_def_brace_next_line_unicodeFunc.T;
P << remove_static_def_brace_next_line_unicodeFunc.P;
p << remove_static_def_brace_next_line_unicodeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unicodeFunc@
F << remove_static_def_no_type_unicodeFunc.F;
P << remove_static_def_no_type_unicodeFunc.P;
p << remove_static_def_no_type_unicodeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unicodeFunc@
F << remove_static_decl_with_type_unicodeFunc.F;
T << remove_static_decl_with_type_unicodeFunc.T;
P << remove_static_decl_with_type_unicodeFunc.P;
p << remove_static_decl_with_type_unicodeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unicodeFunc@
F << remove_static_inline_unicodeFunc.F;
T << remove_static_inline_unicodeFunc.T;
P << remove_static_inline_unicodeFunc.P;
p << remove_static_inline_unicodeFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixAccess
@remove_static_def_brace_same_line_unixAccess@
identifier F = { unixAccess };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixAccess@
identifier F = { unixAccess };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixAccess@
identifier F = { unixAccess };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixAccess@
identifier F = { unixAccess };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixAccess@
identifier F = { unixAccess };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixAccess@
F << remove_static_def_brace_same_line_unixAccess.F;
T << remove_static_def_brace_same_line_unixAccess.T;
P << remove_static_def_brace_same_line_unixAccess.P;
p << remove_static_def_brace_same_line_unixAccess.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixAccess@
F << remove_static_def_brace_next_line_unixAccess.F;
T << remove_static_def_brace_next_line_unixAccess.T;
P << remove_static_def_brace_next_line_unixAccess.P;
p << remove_static_def_brace_next_line_unixAccess.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixAccess@
F << remove_static_def_no_type_unixAccess.F;
P << remove_static_def_no_type_unixAccess.P;
p << remove_static_def_no_type_unixAccess.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixAccess@
F << remove_static_decl_with_type_unixAccess.F;
T << remove_static_decl_with_type_unixAccess.T;
P << remove_static_decl_with_type_unixAccess.P;
p << remove_static_decl_with_type_unixAccess.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixAccess@
F << remove_static_inline_unixAccess.F;
T << remove_static_inline_unixAccess.T;
P << remove_static_inline_unixAccess.P;
p << remove_static_inline_unixAccess.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixClose
@remove_static_def_brace_same_line_unixClose@
identifier F = { unixClose };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixClose@
identifier F = { unixClose };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixClose@
identifier F = { unixClose };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixClose@
identifier F = { unixClose };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixClose@
identifier F = { unixClose };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixClose@
F << remove_static_def_brace_same_line_unixClose.F;
T << remove_static_def_brace_same_line_unixClose.T;
P << remove_static_def_brace_same_line_unixClose.P;
p << remove_static_def_brace_same_line_unixClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixClose@
F << remove_static_def_brace_next_line_unixClose.F;
T << remove_static_def_brace_next_line_unixClose.T;
P << remove_static_def_brace_next_line_unixClose.P;
p << remove_static_def_brace_next_line_unixClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixClose@
F << remove_static_def_no_type_unixClose.F;
P << remove_static_def_no_type_unixClose.P;
p << remove_static_def_no_type_unixClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixClose@
F << remove_static_decl_with_type_unixClose.F;
T << remove_static_decl_with_type_unixClose.T;
P << remove_static_decl_with_type_unixClose.P;
p << remove_static_decl_with_type_unixClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixClose@
F << remove_static_inline_unixClose.F;
T << remove_static_inline_unixClose.T;
P << remove_static_inline_unixClose.P;
p << remove_static_inline_unixClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixCurrentTime
@remove_static_def_brace_same_line_unixCurrentTime@
identifier F = { unixCurrentTime };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixCurrentTime@
identifier F = { unixCurrentTime };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixCurrentTime@
identifier F = { unixCurrentTime };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixCurrentTime@
identifier F = { unixCurrentTime };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixCurrentTime@
identifier F = { unixCurrentTime };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixCurrentTime@
F << remove_static_def_brace_same_line_unixCurrentTime.F;
T << remove_static_def_brace_same_line_unixCurrentTime.T;
P << remove_static_def_brace_same_line_unixCurrentTime.P;
p << remove_static_def_brace_same_line_unixCurrentTime.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixCurrentTime@
F << remove_static_def_brace_next_line_unixCurrentTime.F;
T << remove_static_def_brace_next_line_unixCurrentTime.T;
P << remove_static_def_brace_next_line_unixCurrentTime.P;
p << remove_static_def_brace_next_line_unixCurrentTime.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixCurrentTime@
F << remove_static_def_no_type_unixCurrentTime.F;
P << remove_static_def_no_type_unixCurrentTime.P;
p << remove_static_def_no_type_unixCurrentTime.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixCurrentTime@
F << remove_static_decl_with_type_unixCurrentTime.F;
T << remove_static_decl_with_type_unixCurrentTime.T;
P << remove_static_decl_with_type_unixCurrentTime.P;
p << remove_static_decl_with_type_unixCurrentTime.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixCurrentTime@
F << remove_static_inline_unixCurrentTime.F;
T << remove_static_inline_unixCurrentTime.T;
P << remove_static_inline_unixCurrentTime.P;
p << remove_static_inline_unixCurrentTime.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixCurrentTimeInt64
@remove_static_def_brace_same_line_unixCurrentTimeInt64@
identifier F = { unixCurrentTimeInt64 };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixCurrentTimeInt64@
identifier F = { unixCurrentTimeInt64 };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixCurrentTimeInt64@
identifier F = { unixCurrentTimeInt64 };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixCurrentTimeInt64@
identifier F = { unixCurrentTimeInt64 };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixCurrentTimeInt64@
identifier F = { unixCurrentTimeInt64 };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixCurrentTimeInt64@
F << remove_static_def_brace_same_line_unixCurrentTimeInt64.F;
T << remove_static_def_brace_same_line_unixCurrentTimeInt64.T;
P << remove_static_def_brace_same_line_unixCurrentTimeInt64.P;
p << remove_static_def_brace_same_line_unixCurrentTimeInt64.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixCurrentTimeInt64@
F << remove_static_def_brace_next_line_unixCurrentTimeInt64.F;
T << remove_static_def_brace_next_line_unixCurrentTimeInt64.T;
P << remove_static_def_brace_next_line_unixCurrentTimeInt64.P;
p << remove_static_def_brace_next_line_unixCurrentTimeInt64.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixCurrentTimeInt64@
F << remove_static_def_no_type_unixCurrentTimeInt64.F;
P << remove_static_def_no_type_unixCurrentTimeInt64.P;
p << remove_static_def_no_type_unixCurrentTimeInt64.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixCurrentTimeInt64@
F << remove_static_decl_with_type_unixCurrentTimeInt64.F;
T << remove_static_decl_with_type_unixCurrentTimeInt64.T;
P << remove_static_decl_with_type_unixCurrentTimeInt64.P;
p << remove_static_decl_with_type_unixCurrentTimeInt64.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixCurrentTimeInt64@
F << remove_static_inline_unixCurrentTimeInt64.F;
T << remove_static_inline_unixCurrentTimeInt64.T;
P << remove_static_inline_unixCurrentTimeInt64.P;
p << remove_static_inline_unixCurrentTimeInt64.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixDelete
@remove_static_def_brace_same_line_unixDelete@
identifier F = { unixDelete };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixDelete@
identifier F = { unixDelete };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixDelete@
identifier F = { unixDelete };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixDelete@
identifier F = { unixDelete };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixDelete@
identifier F = { unixDelete };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixDelete@
F << remove_static_def_brace_same_line_unixDelete.F;
T << remove_static_def_brace_same_line_unixDelete.T;
P << remove_static_def_brace_same_line_unixDelete.P;
p << remove_static_def_brace_same_line_unixDelete.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixDelete@
F << remove_static_def_brace_next_line_unixDelete.F;
T << remove_static_def_brace_next_line_unixDelete.T;
P << remove_static_def_brace_next_line_unixDelete.P;
p << remove_static_def_brace_next_line_unixDelete.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixDelete@
F << remove_static_def_no_type_unixDelete.F;
P << remove_static_def_no_type_unixDelete.P;
p << remove_static_def_no_type_unixDelete.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixDelete@
F << remove_static_decl_with_type_unixDelete.F;
T << remove_static_decl_with_type_unixDelete.T;
P << remove_static_decl_with_type_unixDelete.P;
p << remove_static_decl_with_type_unixDelete.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixDelete@
F << remove_static_inline_unixDelete.F;
T << remove_static_inline_unixDelete.T;
P << remove_static_inline_unixDelete.P;
p << remove_static_inline_unixDelete.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixDeviceCharacteristics
@remove_static_def_brace_same_line_unixDeviceCharacteristics@
identifier F = { unixDeviceCharacteristics };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixDeviceCharacteristics@
identifier F = { unixDeviceCharacteristics };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixDeviceCharacteristics@
identifier F = { unixDeviceCharacteristics };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixDeviceCharacteristics@
identifier F = { unixDeviceCharacteristics };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixDeviceCharacteristics@
identifier F = { unixDeviceCharacteristics };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixDeviceCharacteristics@
F << remove_static_def_brace_same_line_unixDeviceCharacteristics.F;
T << remove_static_def_brace_same_line_unixDeviceCharacteristics.T;
P << remove_static_def_brace_same_line_unixDeviceCharacteristics.P;
p << remove_static_def_brace_same_line_unixDeviceCharacteristics.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixDeviceCharacteristics@
F << remove_static_def_brace_next_line_unixDeviceCharacteristics.F;
T << remove_static_def_brace_next_line_unixDeviceCharacteristics.T;
P << remove_static_def_brace_next_line_unixDeviceCharacteristics.P;
p << remove_static_def_brace_next_line_unixDeviceCharacteristics.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixDeviceCharacteristics@
F << remove_static_def_no_type_unixDeviceCharacteristics.F;
P << remove_static_def_no_type_unixDeviceCharacteristics.P;
p << remove_static_def_no_type_unixDeviceCharacteristics.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixDeviceCharacteristics@
F << remove_static_decl_with_type_unixDeviceCharacteristics.F;
T << remove_static_decl_with_type_unixDeviceCharacteristics.T;
P << remove_static_decl_with_type_unixDeviceCharacteristics.P;
p << remove_static_decl_with_type_unixDeviceCharacteristics.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixDeviceCharacteristics@
F << remove_static_inline_unixDeviceCharacteristics.F;
T << remove_static_inline_unixDeviceCharacteristics.T;
P << remove_static_inline_unixDeviceCharacteristics.P;
p << remove_static_inline_unixDeviceCharacteristics.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixDlClose
@remove_static_def_brace_same_line_unixDlClose@
identifier F = { unixDlClose };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixDlClose@
identifier F = { unixDlClose };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixDlClose@
identifier F = { unixDlClose };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixDlClose@
identifier F = { unixDlClose };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixDlClose@
identifier F = { unixDlClose };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixDlClose@
F << remove_static_def_brace_same_line_unixDlClose.F;
T << remove_static_def_brace_same_line_unixDlClose.T;
P << remove_static_def_brace_same_line_unixDlClose.P;
p << remove_static_def_brace_same_line_unixDlClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixDlClose@
F << remove_static_def_brace_next_line_unixDlClose.F;
T << remove_static_def_brace_next_line_unixDlClose.T;
P << remove_static_def_brace_next_line_unixDlClose.P;
p << remove_static_def_brace_next_line_unixDlClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixDlClose@
F << remove_static_def_no_type_unixDlClose.F;
P << remove_static_def_no_type_unixDlClose.P;
p << remove_static_def_no_type_unixDlClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixDlClose@
F << remove_static_decl_with_type_unixDlClose.F;
T << remove_static_decl_with_type_unixDlClose.T;
P << remove_static_decl_with_type_unixDlClose.P;
p << remove_static_decl_with_type_unixDlClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixDlClose@
F << remove_static_inline_unixDlClose.F;
T << remove_static_inline_unixDlClose.T;
P << remove_static_inline_unixDlClose.P;
p << remove_static_inline_unixDlClose.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixDlError
@remove_static_def_brace_same_line_unixDlError@
identifier F = { unixDlError };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixDlError@
identifier F = { unixDlError };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixDlError@
identifier F = { unixDlError };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixDlError@
identifier F = { unixDlError };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixDlError@
identifier F = { unixDlError };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixDlError@
F << remove_static_def_brace_same_line_unixDlError.F;
T << remove_static_def_brace_same_line_unixDlError.T;
P << remove_static_def_brace_same_line_unixDlError.P;
p << remove_static_def_brace_same_line_unixDlError.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixDlError@
F << remove_static_def_brace_next_line_unixDlError.F;
T << remove_static_def_brace_next_line_unixDlError.T;
P << remove_static_def_brace_next_line_unixDlError.P;
p << remove_static_def_brace_next_line_unixDlError.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixDlError@
F << remove_static_def_no_type_unixDlError.F;
P << remove_static_def_no_type_unixDlError.P;
p << remove_static_def_no_type_unixDlError.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixDlError@
F << remove_static_decl_with_type_unixDlError.F;
T << remove_static_decl_with_type_unixDlError.T;
P << remove_static_decl_with_type_unixDlError.P;
p << remove_static_decl_with_type_unixDlError.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixDlError@
F << remove_static_inline_unixDlError.F;
T << remove_static_inline_unixDlError.T;
P << remove_static_inline_unixDlError.P;
p << remove_static_inline_unixDlError.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixDlOpen
@remove_static_def_brace_same_line_unixDlOpen@
identifier F = { unixDlOpen };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixDlOpen@
identifier F = { unixDlOpen };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixDlOpen@
identifier F = { unixDlOpen };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixDlOpen@
identifier F = { unixDlOpen };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixDlOpen@
identifier F = { unixDlOpen };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixDlOpen@
F << remove_static_def_brace_same_line_unixDlOpen.F;
T << remove_static_def_brace_same_line_unixDlOpen.T;
P << remove_static_def_brace_same_line_unixDlOpen.P;
p << remove_static_def_brace_same_line_unixDlOpen.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixDlOpen@
F << remove_static_def_brace_next_line_unixDlOpen.F;
T << remove_static_def_brace_next_line_unixDlOpen.T;
P << remove_static_def_brace_next_line_unixDlOpen.P;
p << remove_static_def_brace_next_line_unixDlOpen.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixDlOpen@
F << remove_static_def_no_type_unixDlOpen.F;
P << remove_static_def_no_type_unixDlOpen.P;
p << remove_static_def_no_type_unixDlOpen.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixDlOpen@
F << remove_static_decl_with_type_unixDlOpen.F;
T << remove_static_decl_with_type_unixDlOpen.T;
P << remove_static_decl_with_type_unixDlOpen.P;
p << remove_static_decl_with_type_unixDlOpen.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixDlOpen@
F << remove_static_inline_unixDlOpen.F;
T << remove_static_inline_unixDlOpen.T;
P << remove_static_inline_unixDlOpen.P;
p << remove_static_inline_unixDlOpen.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixDlSym
@remove_static_def_brace_same_line_unixDlSym@
identifier F = { unixDlSym };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixDlSym@
identifier F = { unixDlSym };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixDlSym@
identifier F = { unixDlSym };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixDlSym@
identifier F = { unixDlSym };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixDlSym@
identifier F = { unixDlSym };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixDlSym@
F << remove_static_def_brace_same_line_unixDlSym.F;
T << remove_static_def_brace_same_line_unixDlSym.T;
P << remove_static_def_brace_same_line_unixDlSym.P;
p << remove_static_def_brace_same_line_unixDlSym.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixDlSym@
F << remove_static_def_brace_next_line_unixDlSym.F;
T << remove_static_def_brace_next_line_unixDlSym.T;
P << remove_static_def_brace_next_line_unixDlSym.P;
p << remove_static_def_brace_next_line_unixDlSym.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixDlSym@
F << remove_static_def_no_type_unixDlSym.F;
P << remove_static_def_no_type_unixDlSym.P;
p << remove_static_def_no_type_unixDlSym.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixDlSym@
F << remove_static_decl_with_type_unixDlSym.F;
T << remove_static_decl_with_type_unixDlSym.T;
P << remove_static_decl_with_type_unixDlSym.P;
p << remove_static_decl_with_type_unixDlSym.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixDlSym@
F << remove_static_inline_unixDlSym.F;
T << remove_static_inline_unixDlSym.T;
P << remove_static_inline_unixDlSym.P;
p << remove_static_inline_unixDlSym.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixFileControl
@remove_static_def_brace_same_line_unixFileControl@
identifier F = { unixFileControl };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixFileControl@
identifier F = { unixFileControl };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixFileControl@
identifier F = { unixFileControl };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixFileControl@
identifier F = { unixFileControl };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixFileControl@
identifier F = { unixFileControl };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixFileControl@
F << remove_static_def_brace_same_line_unixFileControl.F;
T << remove_static_def_brace_same_line_unixFileControl.T;
P << remove_static_def_brace_same_line_unixFileControl.P;
p << remove_static_def_brace_same_line_unixFileControl.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixFileControl@
F << remove_static_def_brace_next_line_unixFileControl.F;
T << remove_static_def_brace_next_line_unixFileControl.T;
P << remove_static_def_brace_next_line_unixFileControl.P;
p << remove_static_def_brace_next_line_unixFileControl.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixFileControl@
F << remove_static_def_no_type_unixFileControl.F;
P << remove_static_def_no_type_unixFileControl.P;
p << remove_static_def_no_type_unixFileControl.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixFileControl@
F << remove_static_decl_with_type_unixFileControl.F;
T << remove_static_decl_with_type_unixFileControl.T;
P << remove_static_decl_with_type_unixFileControl.P;
p << remove_static_decl_with_type_unixFileControl.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixFileControl@
F << remove_static_inline_unixFileControl.F;
T << remove_static_inline_unixFileControl.T;
P << remove_static_inline_unixFileControl.P;
p << remove_static_inline_unixFileControl.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixFileSize
@remove_static_def_brace_same_line_unixFileSize@
identifier F = { unixFileSize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixFileSize@
identifier F = { unixFileSize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixFileSize@
identifier F = { unixFileSize };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixFileSize@
identifier F = { unixFileSize };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixFileSize@
identifier F = { unixFileSize };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixFileSize@
F << remove_static_def_brace_same_line_unixFileSize.F;
T << remove_static_def_brace_same_line_unixFileSize.T;
P << remove_static_def_brace_same_line_unixFileSize.P;
p << remove_static_def_brace_same_line_unixFileSize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixFileSize@
F << remove_static_def_brace_next_line_unixFileSize.F;
T << remove_static_def_brace_next_line_unixFileSize.T;
P << remove_static_def_brace_next_line_unixFileSize.P;
p << remove_static_def_brace_next_line_unixFileSize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixFileSize@
F << remove_static_def_no_type_unixFileSize.F;
P << remove_static_def_no_type_unixFileSize.P;
p << remove_static_def_no_type_unixFileSize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixFileSize@
F << remove_static_decl_with_type_unixFileSize.F;
T << remove_static_decl_with_type_unixFileSize.T;
P << remove_static_decl_with_type_unixFileSize.P;
p << remove_static_decl_with_type_unixFileSize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixFileSize@
F << remove_static_inline_unixFileSize.F;
T << remove_static_inline_unixFileSize.T;
P << remove_static_inline_unixFileSize.P;
p << remove_static_inline_unixFileSize.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixFullPathname
@remove_static_def_brace_same_line_unixFullPathname@
identifier F = { unixFullPathname };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixFullPathname@
identifier F = { unixFullPathname };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixFullPathname@
identifier F = { unixFullPathname };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixFullPathname@
identifier F = { unixFullPathname };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixFullPathname@
identifier F = { unixFullPathname };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixFullPathname@
F << remove_static_def_brace_same_line_unixFullPathname.F;
T << remove_static_def_brace_same_line_unixFullPathname.T;
P << remove_static_def_brace_same_line_unixFullPathname.P;
p << remove_static_def_brace_same_line_unixFullPathname.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixFullPathname@
F << remove_static_def_brace_next_line_unixFullPathname.F;
T << remove_static_def_brace_next_line_unixFullPathname.T;
P << remove_static_def_brace_next_line_unixFullPathname.P;
p << remove_static_def_brace_next_line_unixFullPathname.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixFullPathname@
F << remove_static_def_no_type_unixFullPathname.F;
P << remove_static_def_no_type_unixFullPathname.P;
p << remove_static_def_no_type_unixFullPathname.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixFullPathname@
F << remove_static_decl_with_type_unixFullPathname.F;
T << remove_static_decl_with_type_unixFullPathname.T;
P << remove_static_decl_with_type_unixFullPathname.P;
p << remove_static_decl_with_type_unixFullPathname.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixFullPathname@
F << remove_static_inline_unixFullPathname.F;
T << remove_static_inline_unixFullPathname.T;
P << remove_static_inline_unixFullPathname.P;
p << remove_static_inline_unixFullPathname.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixGetLastError
@remove_static_def_brace_same_line_unixGetLastError@
identifier F = { unixGetLastError };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixGetLastError@
identifier F = { unixGetLastError };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixGetLastError@
identifier F = { unixGetLastError };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixGetLastError@
identifier F = { unixGetLastError };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixGetLastError@
identifier F = { unixGetLastError };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixGetLastError@
F << remove_static_def_brace_same_line_unixGetLastError.F;
T << remove_static_def_brace_same_line_unixGetLastError.T;
P << remove_static_def_brace_same_line_unixGetLastError.P;
p << remove_static_def_brace_same_line_unixGetLastError.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixGetLastError@
F << remove_static_def_brace_next_line_unixGetLastError.F;
T << remove_static_def_brace_next_line_unixGetLastError.T;
P << remove_static_def_brace_next_line_unixGetLastError.P;
p << remove_static_def_brace_next_line_unixGetLastError.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixGetLastError@
F << remove_static_def_no_type_unixGetLastError.F;
P << remove_static_def_no_type_unixGetLastError.P;
p << remove_static_def_no_type_unixGetLastError.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixGetLastError@
F << remove_static_decl_with_type_unixGetLastError.F;
T << remove_static_decl_with_type_unixGetLastError.T;
P << remove_static_decl_with_type_unixGetLastError.P;
p << remove_static_decl_with_type_unixGetLastError.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixGetLastError@
F << remove_static_inline_unixGetLastError.F;
T << remove_static_inline_unixGetLastError.T;
P << remove_static_inline_unixGetLastError.P;
p << remove_static_inline_unixGetLastError.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixGetSystemCall
@remove_static_def_brace_same_line_unixGetSystemCall@
identifier F = { unixGetSystemCall };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixGetSystemCall@
identifier F = { unixGetSystemCall };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixGetSystemCall@
identifier F = { unixGetSystemCall };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixGetSystemCall@
identifier F = { unixGetSystemCall };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixGetSystemCall@
identifier F = { unixGetSystemCall };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixGetSystemCall@
F << remove_static_def_brace_same_line_unixGetSystemCall.F;
T << remove_static_def_brace_same_line_unixGetSystemCall.T;
P << remove_static_def_brace_same_line_unixGetSystemCall.P;
p << remove_static_def_brace_same_line_unixGetSystemCall.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixGetSystemCall@
F << remove_static_def_brace_next_line_unixGetSystemCall.F;
T << remove_static_def_brace_next_line_unixGetSystemCall.T;
P << remove_static_def_brace_next_line_unixGetSystemCall.P;
p << remove_static_def_brace_next_line_unixGetSystemCall.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixGetSystemCall@
F << remove_static_def_no_type_unixGetSystemCall.F;
P << remove_static_def_no_type_unixGetSystemCall.P;
p << remove_static_def_no_type_unixGetSystemCall.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixGetSystemCall@
F << remove_static_decl_with_type_unixGetSystemCall.F;
T << remove_static_decl_with_type_unixGetSystemCall.T;
P << remove_static_decl_with_type_unixGetSystemCall.P;
p << remove_static_decl_with_type_unixGetSystemCall.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixGetSystemCall@
F << remove_static_inline_unixGetSystemCall.F;
T << remove_static_inline_unixGetSystemCall.T;
P << remove_static_inline_unixGetSystemCall.P;
p << remove_static_inline_unixGetSystemCall.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixLock
@remove_static_def_brace_same_line_unixLock@
identifier F = { unixLock };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixLock@
identifier F = { unixLock };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixLock@
identifier F = { unixLock };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixLock@
identifier F = { unixLock };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixLock@
identifier F = { unixLock };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixLock@
F << remove_static_def_brace_same_line_unixLock.F;
T << remove_static_def_brace_same_line_unixLock.T;
P << remove_static_def_brace_same_line_unixLock.P;
p << remove_static_def_brace_same_line_unixLock.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixLock@
F << remove_static_def_brace_next_line_unixLock.F;
T << remove_static_def_brace_next_line_unixLock.T;
P << remove_static_def_brace_next_line_unixLock.P;
p << remove_static_def_brace_next_line_unixLock.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixLock@
F << remove_static_def_no_type_unixLock.F;
P << remove_static_def_no_type_unixLock.P;
p << remove_static_def_no_type_unixLock.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixLock@
F << remove_static_decl_with_type_unixLock.F;
T << remove_static_decl_with_type_unixLock.T;
P << remove_static_decl_with_type_unixLock.P;
p << remove_static_decl_with_type_unixLock.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixLock@
F << remove_static_inline_unixLock.F;
T << remove_static_inline_unixLock.T;
P << remove_static_inline_unixLock.P;
p << remove_static_inline_unixLock.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixNextSystemCall
@remove_static_def_brace_same_line_unixNextSystemCall@
identifier F = { unixNextSystemCall };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixNextSystemCall@
identifier F = { unixNextSystemCall };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixNextSystemCall@
identifier F = { unixNextSystemCall };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixNextSystemCall@
identifier F = { unixNextSystemCall };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixNextSystemCall@
identifier F = { unixNextSystemCall };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixNextSystemCall@
F << remove_static_def_brace_same_line_unixNextSystemCall.F;
T << remove_static_def_brace_same_line_unixNextSystemCall.T;
P << remove_static_def_brace_same_line_unixNextSystemCall.P;
p << remove_static_def_brace_same_line_unixNextSystemCall.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixNextSystemCall@
F << remove_static_def_brace_next_line_unixNextSystemCall.F;
T << remove_static_def_brace_next_line_unixNextSystemCall.T;
P << remove_static_def_brace_next_line_unixNextSystemCall.P;
p << remove_static_def_brace_next_line_unixNextSystemCall.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixNextSystemCall@
F << remove_static_def_no_type_unixNextSystemCall.F;
P << remove_static_def_no_type_unixNextSystemCall.P;
p << remove_static_def_no_type_unixNextSystemCall.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixNextSystemCall@
F << remove_static_decl_with_type_unixNextSystemCall.F;
T << remove_static_decl_with_type_unixNextSystemCall.T;
P << remove_static_decl_with_type_unixNextSystemCall.P;
p << remove_static_decl_with_type_unixNextSystemCall.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixNextSystemCall@
F << remove_static_inline_unixNextSystemCall.F;
T << remove_static_inline_unixNextSystemCall.T;
P << remove_static_inline_unixNextSystemCall.P;
p << remove_static_inline_unixNextSystemCall.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixOpen
@remove_static_def_brace_same_line_unixOpen@
identifier F = { unixOpen };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixOpen@
identifier F = { unixOpen };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixOpen@
identifier F = { unixOpen };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixOpen@
identifier F = { unixOpen };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixOpen@
identifier F = { unixOpen };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixOpen@
F << remove_static_def_brace_same_line_unixOpen.F;
T << remove_static_def_brace_same_line_unixOpen.T;
P << remove_static_def_brace_same_line_unixOpen.P;
p << remove_static_def_brace_same_line_unixOpen.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixOpen@
F << remove_static_def_brace_next_line_unixOpen.F;
T << remove_static_def_brace_next_line_unixOpen.T;
P << remove_static_def_brace_next_line_unixOpen.P;
p << remove_static_def_brace_next_line_unixOpen.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixOpen@
F << remove_static_def_no_type_unixOpen.F;
P << remove_static_def_no_type_unixOpen.P;
p << remove_static_def_no_type_unixOpen.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixOpen@
F << remove_static_decl_with_type_unixOpen.F;
T << remove_static_decl_with_type_unixOpen.T;
P << remove_static_decl_with_type_unixOpen.P;
p << remove_static_decl_with_type_unixOpen.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixOpen@
F << remove_static_inline_unixOpen.F;
T << remove_static_inline_unixOpen.T;
P << remove_static_inline_unixOpen.P;
p << remove_static_inline_unixOpen.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixRandomness
@remove_static_def_brace_same_line_unixRandomness@
identifier F = { unixRandomness };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixRandomness@
identifier F = { unixRandomness };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixRandomness@
identifier F = { unixRandomness };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixRandomness@
identifier F = { unixRandomness };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixRandomness@
identifier F = { unixRandomness };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixRandomness@
F << remove_static_def_brace_same_line_unixRandomness.F;
T << remove_static_def_brace_same_line_unixRandomness.T;
P << remove_static_def_brace_same_line_unixRandomness.P;
p << remove_static_def_brace_same_line_unixRandomness.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixRandomness@
F << remove_static_def_brace_next_line_unixRandomness.F;
T << remove_static_def_brace_next_line_unixRandomness.T;
P << remove_static_def_brace_next_line_unixRandomness.P;
p << remove_static_def_brace_next_line_unixRandomness.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixRandomness@
F << remove_static_def_no_type_unixRandomness.F;
P << remove_static_def_no_type_unixRandomness.P;
p << remove_static_def_no_type_unixRandomness.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixRandomness@
F << remove_static_decl_with_type_unixRandomness.F;
T << remove_static_decl_with_type_unixRandomness.T;
P << remove_static_decl_with_type_unixRandomness.P;
p << remove_static_decl_with_type_unixRandomness.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixRandomness@
F << remove_static_inline_unixRandomness.F;
T << remove_static_inline_unixRandomness.T;
P << remove_static_inline_unixRandomness.P;
p << remove_static_inline_unixRandomness.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixRead
@remove_static_def_brace_same_line_unixRead@
identifier F = { unixRead };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixRead@
identifier F = { unixRead };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixRead@
identifier F = { unixRead };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixRead@
identifier F = { unixRead };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixRead@
identifier F = { unixRead };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixRead@
F << remove_static_def_brace_same_line_unixRead.F;
T << remove_static_def_brace_same_line_unixRead.T;
P << remove_static_def_brace_same_line_unixRead.P;
p << remove_static_def_brace_same_line_unixRead.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixRead@
F << remove_static_def_brace_next_line_unixRead.F;
T << remove_static_def_brace_next_line_unixRead.T;
P << remove_static_def_brace_next_line_unixRead.P;
p << remove_static_def_brace_next_line_unixRead.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixRead@
F << remove_static_def_no_type_unixRead.F;
P << remove_static_def_no_type_unixRead.P;
p << remove_static_def_no_type_unixRead.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixRead@
F << remove_static_decl_with_type_unixRead.F;
T << remove_static_decl_with_type_unixRead.T;
P << remove_static_decl_with_type_unixRead.P;
p << remove_static_decl_with_type_unixRead.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixRead@
F << remove_static_inline_unixRead.F;
T << remove_static_inline_unixRead.T;
P << remove_static_inline_unixRead.P;
p << remove_static_inline_unixRead.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixSetSystemCall
@remove_static_def_brace_same_line_unixSetSystemCall@
identifier F = { unixSetSystemCall };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixSetSystemCall@
identifier F = { unixSetSystemCall };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixSetSystemCall@
identifier F = { unixSetSystemCall };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixSetSystemCall@
identifier F = { unixSetSystemCall };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixSetSystemCall@
identifier F = { unixSetSystemCall };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixSetSystemCall@
F << remove_static_def_brace_same_line_unixSetSystemCall.F;
T << remove_static_def_brace_same_line_unixSetSystemCall.T;
P << remove_static_def_brace_same_line_unixSetSystemCall.P;
p << remove_static_def_brace_same_line_unixSetSystemCall.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixSetSystemCall@
F << remove_static_def_brace_next_line_unixSetSystemCall.F;
T << remove_static_def_brace_next_line_unixSetSystemCall.T;
P << remove_static_def_brace_next_line_unixSetSystemCall.P;
p << remove_static_def_brace_next_line_unixSetSystemCall.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixSetSystemCall@
F << remove_static_def_no_type_unixSetSystemCall.F;
P << remove_static_def_no_type_unixSetSystemCall.P;
p << remove_static_def_no_type_unixSetSystemCall.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixSetSystemCall@
F << remove_static_decl_with_type_unixSetSystemCall.F;
T << remove_static_decl_with_type_unixSetSystemCall.T;
P << remove_static_decl_with_type_unixSetSystemCall.P;
p << remove_static_decl_with_type_unixSetSystemCall.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixSetSystemCall@
F << remove_static_inline_unixSetSystemCall.F;
T << remove_static_inline_unixSetSystemCall.T;
P << remove_static_inline_unixSetSystemCall.P;
p << remove_static_inline_unixSetSystemCall.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixSleep
@remove_static_def_brace_same_line_unixSleep@
identifier F = { unixSleep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixSleep@
identifier F = { unixSleep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixSleep@
identifier F = { unixSleep };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixSleep@
identifier F = { unixSleep };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixSleep@
identifier F = { unixSleep };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixSleep@
F << remove_static_def_brace_same_line_unixSleep.F;
T << remove_static_def_brace_same_line_unixSleep.T;
P << remove_static_def_brace_same_line_unixSleep.P;
p << remove_static_def_brace_same_line_unixSleep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixSleep@
F << remove_static_def_brace_next_line_unixSleep.F;
T << remove_static_def_brace_next_line_unixSleep.T;
P << remove_static_def_brace_next_line_unixSleep.P;
p << remove_static_def_brace_next_line_unixSleep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixSleep@
F << remove_static_def_no_type_unixSleep.F;
P << remove_static_def_no_type_unixSleep.P;
p << remove_static_def_no_type_unixSleep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixSleep@
F << remove_static_decl_with_type_unixSleep.F;
T << remove_static_decl_with_type_unixSleep.T;
P << remove_static_decl_with_type_unixSleep.P;
p << remove_static_decl_with_type_unixSleep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixSleep@
F << remove_static_inline_unixSleep.F;
T << remove_static_inline_unixSleep.T;
P << remove_static_inline_unixSleep.P;
p << remove_static_inline_unixSleep.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixSync
@remove_static_def_brace_same_line_unixSync@
identifier F = { unixSync };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixSync@
identifier F = { unixSync };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixSync@
identifier F = { unixSync };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixSync@
identifier F = { unixSync };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixSync@
identifier F = { unixSync };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixSync@
F << remove_static_def_brace_same_line_unixSync.F;
T << remove_static_def_brace_same_line_unixSync.T;
P << remove_static_def_brace_same_line_unixSync.P;
p << remove_static_def_brace_same_line_unixSync.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixSync@
F << remove_static_def_brace_next_line_unixSync.F;
T << remove_static_def_brace_next_line_unixSync.T;
P << remove_static_def_brace_next_line_unixSync.P;
p << remove_static_def_brace_next_line_unixSync.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixSync@
F << remove_static_def_no_type_unixSync.F;
P << remove_static_def_no_type_unixSync.P;
p << remove_static_def_no_type_unixSync.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixSync@
F << remove_static_decl_with_type_unixSync.F;
T << remove_static_decl_with_type_unixSync.T;
P << remove_static_decl_with_type_unixSync.P;
p << remove_static_decl_with_type_unixSync.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixSync@
F << remove_static_inline_unixSync.F;
T << remove_static_inline_unixSync.T;
P << remove_static_inline_unixSync.P;
p << remove_static_inline_unixSync.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixUnlock
@remove_static_def_brace_same_line_unixUnlock@
identifier F = { unixUnlock };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixUnlock@
identifier F = { unixUnlock };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixUnlock@
identifier F = { unixUnlock };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixUnlock@
identifier F = { unixUnlock };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixUnlock@
identifier F = { unixUnlock };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixUnlock@
F << remove_static_def_brace_same_line_unixUnlock.F;
T << remove_static_def_brace_same_line_unixUnlock.T;
P << remove_static_def_brace_same_line_unixUnlock.P;
p << remove_static_def_brace_same_line_unixUnlock.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixUnlock@
F << remove_static_def_brace_next_line_unixUnlock.F;
T << remove_static_def_brace_next_line_unixUnlock.T;
P << remove_static_def_brace_next_line_unixUnlock.P;
p << remove_static_def_brace_next_line_unixUnlock.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixUnlock@
F << remove_static_def_no_type_unixUnlock.F;
P << remove_static_def_no_type_unixUnlock.P;
p << remove_static_def_no_type_unixUnlock.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixUnlock@
F << remove_static_decl_with_type_unixUnlock.F;
T << remove_static_decl_with_type_unixUnlock.T;
P << remove_static_decl_with_type_unixUnlock.P;
p << remove_static_decl_with_type_unixUnlock.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixUnlock@
F << remove_static_inline_unixUnlock.F;
T << remove_static_inline_unixUnlock.T;
P << remove_static_inline_unixUnlock.P;
p << remove_static_inline_unixUnlock.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixWrite
@remove_static_def_brace_same_line_unixWrite@
identifier F = { unixWrite };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixWrite@
identifier F = { unixWrite };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixWrite@
identifier F = { unixWrite };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixWrite@
identifier F = { unixWrite };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixWrite@
identifier F = { unixWrite };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixWrite@
F << remove_static_def_brace_same_line_unixWrite.F;
T << remove_static_def_brace_same_line_unixWrite.T;
P << remove_static_def_brace_same_line_unixWrite.P;
p << remove_static_def_brace_same_line_unixWrite.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixWrite@
F << remove_static_def_brace_next_line_unixWrite.F;
T << remove_static_def_brace_next_line_unixWrite.T;
P << remove_static_def_brace_next_line_unixWrite.P;
p << remove_static_def_brace_next_line_unixWrite.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixWrite@
F << remove_static_def_no_type_unixWrite.F;
P << remove_static_def_no_type_unixWrite.P;
p << remove_static_def_no_type_unixWrite.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixWrite@
F << remove_static_decl_with_type_unixWrite.F;
T << remove_static_decl_with_type_unixWrite.T;
P << remove_static_decl_with_type_unixWrite.P;
p << remove_static_decl_with_type_unixWrite.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixWrite@
F << remove_static_inline_unixWrite.F;
T << remove_static_inline_unixWrite.T;
P << remove_static_inline_unixWrite.P;
p << remove_static_inline_unixWrite.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: unixepochFunc
@remove_static_def_brace_same_line_unixepochFunc@
identifier F = { unixepochFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_unixepochFunc@
identifier F = { unixepochFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_unixepochFunc@
identifier F = { unixepochFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_unixepochFunc@
identifier F = { unixepochFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_unixepochFunc@
identifier F = { unixepochFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_unixepochFunc@
F << remove_static_def_brace_same_line_unixepochFunc.F;
T << remove_static_def_brace_same_line_unixepochFunc.T;
P << remove_static_def_brace_same_line_unixepochFunc.P;
p << remove_static_def_brace_same_line_unixepochFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_unixepochFunc@
F << remove_static_def_brace_next_line_unixepochFunc.F;
T << remove_static_def_brace_next_line_unixepochFunc.T;
P << remove_static_def_brace_next_line_unixepochFunc.P;
p << remove_static_def_brace_next_line_unixepochFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_unixepochFunc@
F << remove_static_def_no_type_unixepochFunc.F;
P << remove_static_def_no_type_unixepochFunc.P;
p << remove_static_def_no_type_unixepochFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_unixepochFunc@
F << remove_static_decl_with_type_unixepochFunc.F;
T << remove_static_decl_with_type_unixepochFunc.T;
P << remove_static_decl_with_type_unixepochFunc.P;
p << remove_static_decl_with_type_unixepochFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_unixepochFunc@
F << remove_static_inline_unixepochFunc.F;
T << remove_static_inline_unixepochFunc.T;
P << remove_static_inline_unixepochFunc.P;
p << remove_static_inline_unixepochFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: upperFunc
@remove_static_def_brace_same_line_upperFunc@
identifier F = { upperFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_upperFunc@
identifier F = { upperFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_upperFunc@
identifier F = { upperFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_upperFunc@
identifier F = { upperFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_upperFunc@
identifier F = { upperFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_upperFunc@
F << remove_static_def_brace_same_line_upperFunc.F;
T << remove_static_def_brace_same_line_upperFunc.T;
P << remove_static_def_brace_same_line_upperFunc.P;
p << remove_static_def_brace_same_line_upperFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_upperFunc@
F << remove_static_def_brace_next_line_upperFunc.F;
T << remove_static_def_brace_next_line_upperFunc.T;
P << remove_static_def_brace_next_line_upperFunc.P;
p << remove_static_def_brace_next_line_upperFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_upperFunc@
F << remove_static_def_no_type_upperFunc.F;
P << remove_static_def_no_type_upperFunc.P;
p << remove_static_def_no_type_upperFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_upperFunc@
F << remove_static_decl_with_type_upperFunc.F;
T << remove_static_decl_with_type_upperFunc.T;
P << remove_static_decl_with_type_upperFunc.P;
p << remove_static_decl_with_type_upperFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_upperFunc@
F << remove_static_inline_upperFunc.F;
T << remove_static_inline_upperFunc.T;
P << remove_static_inline_upperFunc.P;
p << remove_static_inline_upperFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: vdbeRecordCompareInt
@remove_static_def_brace_same_line_vdbeRecordCompareInt@
identifier F = { vdbeRecordCompareInt };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_vdbeRecordCompareInt@
identifier F = { vdbeRecordCompareInt };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_vdbeRecordCompareInt@
identifier F = { vdbeRecordCompareInt };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_vdbeRecordCompareInt@
identifier F = { vdbeRecordCompareInt };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_vdbeRecordCompareInt@
identifier F = { vdbeRecordCompareInt };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_vdbeRecordCompareInt@
F << remove_static_def_brace_same_line_vdbeRecordCompareInt.F;
T << remove_static_def_brace_same_line_vdbeRecordCompareInt.T;
P << remove_static_def_brace_same_line_vdbeRecordCompareInt.P;
p << remove_static_def_brace_same_line_vdbeRecordCompareInt.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_vdbeRecordCompareInt@
F << remove_static_def_brace_next_line_vdbeRecordCompareInt.F;
T << remove_static_def_brace_next_line_vdbeRecordCompareInt.T;
P << remove_static_def_brace_next_line_vdbeRecordCompareInt.P;
p << remove_static_def_brace_next_line_vdbeRecordCompareInt.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_vdbeRecordCompareInt@
F << remove_static_def_no_type_vdbeRecordCompareInt.F;
P << remove_static_def_no_type_vdbeRecordCompareInt.P;
p << remove_static_def_no_type_vdbeRecordCompareInt.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_vdbeRecordCompareInt@
F << remove_static_decl_with_type_vdbeRecordCompareInt.F;
T << remove_static_decl_with_type_vdbeRecordCompareInt.T;
P << remove_static_decl_with_type_vdbeRecordCompareInt.P;
p << remove_static_decl_with_type_vdbeRecordCompareInt.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_vdbeRecordCompareInt@
F << remove_static_inline_vdbeRecordCompareInt.F;
T << remove_static_inline_vdbeRecordCompareInt.T;
P << remove_static_inline_vdbeRecordCompareInt.P;
p << remove_static_inline_vdbeRecordCompareInt.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: vdbeRecordCompareString
@remove_static_def_brace_same_line_vdbeRecordCompareString@
identifier F = { vdbeRecordCompareString };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_vdbeRecordCompareString@
identifier F = { vdbeRecordCompareString };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_vdbeRecordCompareString@
identifier F = { vdbeRecordCompareString };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_vdbeRecordCompareString@
identifier F = { vdbeRecordCompareString };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_vdbeRecordCompareString@
identifier F = { vdbeRecordCompareString };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_vdbeRecordCompareString@
F << remove_static_def_brace_same_line_vdbeRecordCompareString.F;
T << remove_static_def_brace_same_line_vdbeRecordCompareString.T;
P << remove_static_def_brace_same_line_vdbeRecordCompareString.P;
p << remove_static_def_brace_same_line_vdbeRecordCompareString.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_vdbeRecordCompareString@
F << remove_static_def_brace_next_line_vdbeRecordCompareString.F;
T << remove_static_def_brace_next_line_vdbeRecordCompareString.T;
P << remove_static_def_brace_next_line_vdbeRecordCompareString.P;
p << remove_static_def_brace_next_line_vdbeRecordCompareString.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_vdbeRecordCompareString@
F << remove_static_def_no_type_vdbeRecordCompareString.F;
P << remove_static_def_no_type_vdbeRecordCompareString.P;
p << remove_static_def_no_type_vdbeRecordCompareString.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_vdbeRecordCompareString@
F << remove_static_decl_with_type_vdbeRecordCompareString.F;
T << remove_static_decl_with_type_vdbeRecordCompareString.T;
P << remove_static_decl_with_type_vdbeRecordCompareString.P;
p << remove_static_decl_with_type_vdbeRecordCompareString.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_vdbeRecordCompareString@
F << remove_static_inline_vdbeRecordCompareString.F;
T << remove_static_inline_vdbeRecordCompareString.T;
P << remove_static_inline_vdbeRecordCompareString.P;
p << remove_static_inline_vdbeRecordCompareString.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: vdbeSorterCompareInt
@remove_static_def_brace_same_line_vdbeSorterCompareInt@
identifier F = { vdbeSorterCompareInt };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_vdbeSorterCompareInt@
identifier F = { vdbeSorterCompareInt };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_vdbeSorterCompareInt@
identifier F = { vdbeSorterCompareInt };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_vdbeSorterCompareInt@
identifier F = { vdbeSorterCompareInt };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_vdbeSorterCompareInt@
identifier F = { vdbeSorterCompareInt };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_vdbeSorterCompareInt@
F << remove_static_def_brace_same_line_vdbeSorterCompareInt.F;
T << remove_static_def_brace_same_line_vdbeSorterCompareInt.T;
P << remove_static_def_brace_same_line_vdbeSorterCompareInt.P;
p << remove_static_def_brace_same_line_vdbeSorterCompareInt.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_vdbeSorterCompareInt@
F << remove_static_def_brace_next_line_vdbeSorterCompareInt.F;
T << remove_static_def_brace_next_line_vdbeSorterCompareInt.T;
P << remove_static_def_brace_next_line_vdbeSorterCompareInt.P;
p << remove_static_def_brace_next_line_vdbeSorterCompareInt.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_vdbeSorterCompareInt@
F << remove_static_def_no_type_vdbeSorterCompareInt.F;
P << remove_static_def_no_type_vdbeSorterCompareInt.P;
p << remove_static_def_no_type_vdbeSorterCompareInt.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_vdbeSorterCompareInt@
F << remove_static_decl_with_type_vdbeSorterCompareInt.F;
T << remove_static_decl_with_type_vdbeSorterCompareInt.T;
P << remove_static_decl_with_type_vdbeSorterCompareInt.P;
p << remove_static_decl_with_type_vdbeSorterCompareInt.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_vdbeSorterCompareInt@
F << remove_static_inline_vdbeSorterCompareInt.F;
T << remove_static_inline_vdbeSorterCompareInt.T;
P << remove_static_inline_vdbeSorterCompareInt.P;
p << remove_static_inline_vdbeSorterCompareInt.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: vdbeSorterCompareText
@remove_static_def_brace_same_line_vdbeSorterCompareText@
identifier F = { vdbeSorterCompareText };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_vdbeSorterCompareText@
identifier F = { vdbeSorterCompareText };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_vdbeSorterCompareText@
identifier F = { vdbeSorterCompareText };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_vdbeSorterCompareText@
identifier F = { vdbeSorterCompareText };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_vdbeSorterCompareText@
identifier F = { vdbeSorterCompareText };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_vdbeSorterCompareText@
F << remove_static_def_brace_same_line_vdbeSorterCompareText.F;
T << remove_static_def_brace_same_line_vdbeSorterCompareText.T;
P << remove_static_def_brace_same_line_vdbeSorterCompareText.P;
p << remove_static_def_brace_same_line_vdbeSorterCompareText.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_vdbeSorterCompareText@
F << remove_static_def_brace_next_line_vdbeSorterCompareText.F;
T << remove_static_def_brace_next_line_vdbeSorterCompareText.T;
P << remove_static_def_brace_next_line_vdbeSorterCompareText.P;
p << remove_static_def_brace_next_line_vdbeSorterCompareText.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_vdbeSorterCompareText@
F << remove_static_def_no_type_vdbeSorterCompareText.F;
P << remove_static_def_no_type_vdbeSorterCompareText.P;
p << remove_static_def_no_type_vdbeSorterCompareText.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_vdbeSorterCompareText@
F << remove_static_decl_with_type_vdbeSorterCompareText.F;
T << remove_static_decl_with_type_vdbeSorterCompareText.T;
P << remove_static_decl_with_type_vdbeSorterCompareText.P;
p << remove_static_decl_with_type_vdbeSorterCompareText.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_vdbeSorterCompareText@
F << remove_static_inline_vdbeSorterCompareText.F;
T << remove_static_inline_vdbeSorterCompareText.T;
P << remove_static_inline_vdbeSorterCompareText.P;
p << remove_static_inline_vdbeSorterCompareText.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: versionFunc
@remove_static_def_brace_same_line_versionFunc@
identifier F = { versionFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_versionFunc@
identifier F = { versionFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_versionFunc@
identifier F = { versionFunc };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_versionFunc@
identifier F = { versionFunc };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_versionFunc@
identifier F = { versionFunc };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_versionFunc@
F << remove_static_def_brace_same_line_versionFunc.F;
T << remove_static_def_brace_same_line_versionFunc.T;
P << remove_static_def_brace_same_line_versionFunc.P;
p << remove_static_def_brace_same_line_versionFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_versionFunc@
F << remove_static_def_brace_next_line_versionFunc.F;
T << remove_static_def_brace_next_line_versionFunc.T;
P << remove_static_def_brace_next_line_versionFunc.P;
p << remove_static_def_brace_next_line_versionFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_versionFunc@
F << remove_static_def_no_type_versionFunc.F;
P << remove_static_def_no_type_versionFunc.P;
p << remove_static_def_no_type_versionFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_versionFunc@
F << remove_static_decl_with_type_versionFunc.F;
T << remove_static_decl_with_type_versionFunc.T;
P << remove_static_decl_with_type_versionFunc.P;
p << remove_static_decl_with_type_versionFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_versionFunc@
F << remove_static_inline_versionFunc.F;
T << remove_static_inline_versionFunc.T;
P << remove_static_inline_versionFunc.P;
p << remove_static_inline_versionFunc.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: xCeil
@remove_static_def_brace_same_line_xCeil@
identifier F = { xCeil };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_xCeil@
identifier F = { xCeil };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_xCeil@
identifier F = { xCeil };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_xCeil@
identifier F = { xCeil };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_xCeil@
identifier F = { xCeil };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_xCeil@
F << remove_static_def_brace_same_line_xCeil.F;
T << remove_static_def_brace_same_line_xCeil.T;
P << remove_static_def_brace_same_line_xCeil.P;
p << remove_static_def_brace_same_line_xCeil.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_xCeil@
F << remove_static_def_brace_next_line_xCeil.F;
T << remove_static_def_brace_next_line_xCeil.T;
P << remove_static_def_brace_next_line_xCeil.P;
p << remove_static_def_brace_next_line_xCeil.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_xCeil@
F << remove_static_def_no_type_xCeil.F;
P << remove_static_def_no_type_xCeil.P;
p << remove_static_def_no_type_xCeil.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_xCeil@
F << remove_static_decl_with_type_xCeil.F;
T << remove_static_decl_with_type_xCeil.T;
P << remove_static_decl_with_type_xCeil.P;
p << remove_static_decl_with_type_xCeil.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_xCeil@
F << remove_static_inline_xCeil.F;
T << remove_static_inline_xCeil.T;
P << remove_static_inline_xCeil.P;
p << remove_static_inline_xCeil.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


// Rules for function: xFloor
@remove_static_def_brace_same_line_xFloor@
identifier F = { xFloor };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P) { BODY }

@remove_static_def_brace_next_line_xFloor@
identifier F = { xFloor };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
T F(P)
{ BODY }

@remove_static_def_no_type_xFloor@
identifier F = { xFloor };
parameter list P;
statement list BODY;
position p;
@@
- static@p
F(P) { BODY }

@remove_static_decl_with_type_xFloor@
identifier F = { xFloor };
type T;
parameter list P;
position p;
@@
- static@p
T F(P);

@remove_static_inline_xFloor@
identifier F = { xFloor };
type T;
parameter list P;
statement list BODY;
position p;
@@
- static@p
inline T F(P) { BODY }


@script:python depends on remove_static_def_brace_same_line_xFloor@
F << remove_static_def_brace_same_line_xFloor.F;
T << remove_static_def_brace_same_line_xFloor.T;
P << remove_static_def_brace_same_line_xFloor.P;
p << remove_static_def_brace_same_line_xFloor.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_brace_next_line_xFloor@
F << remove_static_def_brace_next_line_xFloor.F;
T << remove_static_def_brace_next_line_xFloor.T;
P << remove_static_def_brace_next_line_xFloor.P;
p << remove_static_def_brace_next_line_xFloor.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_def_no_type_xFloor@
F << remove_static_def_no_type_xFloor.F;
P << remove_static_def_no_type_xFloor.P;
p << remove_static_def_no_type_xFloor.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"void {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_decl_with_type_xFloor@
F << remove_static_decl_with_type_xFloor.F;
T << remove_static_decl_with_type_xFloor.T;
P << remove_static_decl_with_type_xFloor.P;
p << remove_static_decl_with_type_xFloor.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")



@script:python depends on remove_static_inline_xFloor@
F << remove_static_inline_xFloor.F;
T << remove_static_inline_xFloor.T;
P << remove_static_inline_xFloor.P;
p << remove_static_inline_xFloor.p;
@@
import os
import re

def clean_function_signature(signature):
    '''Clean up function signature formatting with improved pointer handling'''
    if not signature:
        return signature
    
    # Step 1: Normalize all whitespace to single spaces
    signature = re.sub(r'\s+', ' ', signature.strip())
    
    # Step 2: Remove all spaces around asterisks first to start clean
    signature = re.sub(r'\s*\*\s*', '*', signature)
    
    # Step 3: Add space before asterisk groups (but not after)
    # Match patterns like "type*" or "type**" and convert to "type *" or "type **"
    signature = re.sub(r'(\w)(\*+)', r'\1 \2', signature)
    
    # Step 4: Clean up any double spaces that might have been introduced
    signature = re.sub(r'\s+', ' ', signature)
    
    return signature.strip()

os.makedirs("definitions", exist_ok=True)
clean_signature = clean_function_signature(f"{T} {F}({P});")
with open(f"definitions/{F}.txt", "w") as f:
    f.write(f"{clean_signature}\n")
print(f"[EXTRACTED] {F} definition saved to definitions/{F}.txt")


@script:python@
@@
import os
import glob

print("\n>>> EXTRACTION SUMMARY")
def_files = glob.glob("definitions/*.txt")
print(f">>> Total function declarations extracted: {len(def_files)}")

if def_files:
    print(">>> Extracted functions:")
    for def_file in sorted(def_files):
        func_name = os.path.basename(def_file).replace('.txt', '')
        try:
            with open(def_file, 'r') as f:
                signature = f.read().strip()
            print(f">>>   {func_name}: {signature}")
        except:
            print(f">>>   {func_name}: [ERROR reading file]")

print(">>> Use these declarations when adding function prototypes")

@finalize:python@
@@
print(">>> Completed processing 182 functions")
print(">>> From JSON: 160, Additional SQLite structures: 22")
print(">>> Function declarations extracted to definitions/ folder")
